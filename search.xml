<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器如何学习？]]></title>
    <url>%2F2017%2F11%2F26%2Fhow-machine-learning-to-learn%2F</url>
    <content type="text"><![CDATA[机器学习的目标是获得一组最优的参数，这些参数决定了评分函数，因此我们要找一个最优的评分函数。实际上通过引入损失函数，我们可以通过最小化损失函数来不断更新评分函数的参数，具体来说，机器学习可以通过一种迭代的技术，使得每一步的迭代之后，损失函数的输出都能减小，因此在有限步迭代之后，损失函数就能达到最小值点（当然这是一个局部最小值）。在每一次迭代之后，我们都会根据损失函数的输出更新评分函数的参数，这样就达到了学习的目的。 随机梯度下降随机梯度下降（Stochastic gradient decent，SGD）就是这样一种迭代技术。基于函数f的梯度负方向$-\Delta f$是这个函数下降最快的方向，SGD通过从某个点$w_0$出发，不断沿着梯度负方向前进一个小步长$\eta$来达到求函数f的局部最优解的目的：$$w^*=argmin_wf(w) \qquad (1)$$ 假设经过I步达到最优点$w^*$，那么寻找最优解的过程如下： $$w_1 = w_0 - \eta \Delta f(w_0) \\w_2 = w_1 - \eta \Delta f(w_1) \\\cdot\cdot\cdot \\w^* = w_{I-1} - \eta \Delta f(w_{I-1})$$ 这里步长$\eta$的设置一般是动态的，如果设定为固定值，从点$w_0$到最优点的轨迹有点像Z字形，收敛的时间会很长，所以一般都会动态地减小步长值。 导数为了进行迭代，我们必须要在每一步里计算当前点的梯度，也就是导数：$$\frac{d}{dx}f = \lim_{x\to x_0}\frac {f(x) - f(x_0)}{x - x_0} $$ 考虑到实际上机器学习的函数十分复杂，首先它是评分函数和损失函数组成的复合函数：$$F = Loss(Score(x))$$其次，评分函数有可能十分复杂，比如，在深度学习里，评分函数是一系列网络层的复合，假设有N个网络层，每个网络的函数是$K_{i}$，那么评分函数就是这N个网络层的复合函数： $$Score(x)=K_{n}(K_{n-1}(…K_1(x)))$$ 链式法则因此一般的机器学习框架都会采用一种后向自动微分的方式求导数。这种方式不仅不需要使用微积分的分析方式求出导数的表达式，运算效率还特别高。其中的原理是运用了复合函数求导的链式法则：$$\frac {d}{dx}f(y(x)) = \frac {df}{dy} \frac{dy}{dx}$$ 比如，要计算$$y = sin(x^2)$$在$x=1$处的导数，首先我们分成几步计算y的值：$$\begin{align}&amp; x_0 = 1 \\&amp; x_1 = x_0^2 = 1 \\&amp; x_2 = sin(x_1) = 0.8415 \\&amp; y = x_2 = 0.8415\end{align}$$计算导数时，只需反过来对每一步求导即可： $$\begin{align}&amp; \bar{v_2} = \bar y = 1 \\&amp; \bar{v_1} = \bar{v_2}\frac{dv_2}{dv_1} = \bar{v_2} \times cos(x_1) = 0.8415 \\&amp; \bar{v_0} = \bar{v_1}\frac{dv_1}{dv_0} = \bar{v_1} \times 2x_0 = 1.0806\end{align}$$ 对于这个例子，我们可以很快验证，函数f的导数是：$$\frac{dy}{dx} = cos(x^2)\cdot 2x$$代入x=1，得：$$cos(1)\times 2 = 1.0806$$ 因此，自动微分的好处在于我们不必显示地用微积分的方法求解导数表达式。在caffe2中，我们只需要对每一层的函数编码导数的表达式，整个神经网络表示的大函数的梯度则通过自动微分的方式汇集每一层的导数值得来。 SVM Loss的梯度SoftMax Loss的梯度]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>机器学习</tag>
        <tag>随机梯度下降</tag>
        <tag>求导</tag>
        <tag>链式法则</tag>
        <tag>自动微分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何衡量机器学习的好坏]]></title>
    <url>%2F2017%2F11%2F24%2Fmeasuse-machine-learning-performance%2F</url>
    <content type="text"><![CDATA[损失函数定义了机器学习的目标，是构建机器学习结构十分重要的一环。通常，损失函数包含数据损失(data loss)和正则化损失(regularization loss)，前者约束评分函数预测的结果要和真实结果尽可能相近，后者约束的是评分函数的参数要尽可能简单，避免过复杂的模型。对于不同的任务（分类、回归等），需要设计不同类型的损失函数，当然使用最多的损失函数就只有常见的几种，下面分别介绍。 数据损失适用于分类的损失函数对于一个N类的分类任务，对于每一个输入的样本，评分函数都会输出一个N维的向量，这个向量表明了该样本对应于某个类的得分（向量的第一个值表明该样本属于第一类的得分，第n个值表明该样本属于第n类的得分），得分最高的那个类别就是电脑预测的类别结果。 在训练的时候，我们还有每个样本真实的类别数据，通过比较电脑预测的结果和真实结果的差异，我们就能知道电脑预测的好坏，损失函数就是用来做比较差异这件事情的，所以损失函数会以电脑的预测结果和真实的类别结果为输入，输出一个实数值。 用数学语言总结一下，对于N类的分类任务，对于样本$x_i$，电脑预测的结果，回忆一下上一篇blog，就是评分函数输出的结果：$$s_j = f(x_i,W)_j$$函数f会输出一个N维的得分向量，$f(x_i,W)_j$表示这个向量的第j个元素，即这个样本属于第j类的得分。假设这个样本的真实的类别是$y_i$，那么损失函数是所有样本的损失的平均： $$L = \frac{1}{N}\sum_{i=0}^N l_i(f(x_i,W),y_i)$$ Multiclass Support Vector Machine loss多类支持向量机损失函数是这样一个损失函数：它希望正确类别的得分比其他类别的得分高于某个固定的值$\Delta$，通常可以将$\Delta$设为1。于是，第i个样本的SVM损失值可以用下面的式子表示：$$L_i=\sum_{j\neq{y_i}} max(0, s_j - s_{y_i} + \Delta)$$其中$s_j$是预测的第j类的得分，$y_i$是样本$x_i$的真实类别, $s_{y_i}$是在真实类别上的得分。注意到这里求和的不包括真实类别的那一项，而是将其它类别的得分与真实类别的得分相减，看是否大于固定值$\Delta$，如果大于的话就累加到loss里去，如果小于的话损失就置为0（说明其他类别的得分都小于真实类别的得分）。下面是在caffe2中的实现代码，关于如何在caffe2中添加自定义层可以参考这里。template &lt;&gt;bool SVMLossL1Op&lt;float, CPUContext&gt;::RunOnDevice() &#123; // (1) 设置输入输出 auto&amp; X = Input(0); const float* Xdata = X.data&lt;float&gt;(); auto&amp; labels = Input(1); const int* labels_data = labels.data&lt;int&gt;(); auto* Y = Output(0); const auto canonical_axis = X.canonical_axis_index(axis_); const int N = X.size_to_dim(canonical_axis); const int D = X.size_from_dim(canonical_axis); Y-&gt;Resize(N); float* Ydata = Y-&gt;mutable_data&lt;float&gt;(); // （2）获取真实标签所对应的得分 if (correct_class_score_.size() != N) &#123; correct_class_score_.Resize(N); &#125; float* correct_class_score_data = correct_class_score_.mutable_data&lt;float&gt;(); math::Select&lt;float, CPUContext&gt;(N, D, Xdata, labels_data, correct_class_score_data, &amp;context_); // (3) 计算每一个样本的svm损失 // sum(max(0, result X - correct_class_score(X) + 1)) for (int i = 0; i &lt; N; ++i) &#123; Ydata[i] = 0.0; for (int j = 0; j &lt; D; ++j) &#123; if (j != labels_data[i]) &#123; // sum wrong class margin Ydata[i] += std::max&lt;float&gt;( 0.0, Xdata[i * D + j] - correct_class_score_data[i] + 1); &#125; &#125; &#125; return true;&#125; (1) 设置输入和输出。Loss函数有两个输入，一个是评分函数预测的每类的得分，假设共有D类，那么X应该是一个D维的向量，但是通常我们会设置一个batch的数据过网络，假设有N个数据一起过网络，那么X就是$N \times D$维。labels是N个数据真实的标签，是一个N维的变量。Loss函数只有一个输出，是一个N维的向量。 (2）获取真实标签所对应的得分。这里对应的是$s_{y_i}$ (3) 计算每一个样本的svm损失。 多类支持向量机损失函数有一些变种，比如，为了让损失函数便于求导，求和时可以加上平方：$$L_i=\sum_{j\neq{y_i}} max(0, s_j - s_{y_i} + \Delta)^2$$ Cross-Entropy loss在理解交叉熵损失函数之前，首先看一下Softmax操作。回想一下SVM loss，它的输入是一个N维的评分向量（N表示总类别数），这里的评分是在实数域上的，也就是说可以是任意的实数。而Softmax操作可以将这N个数归一化到[0,1]之间，并且使这N个数之和为1。这种方式实际上模拟了类别的概率分布，是我们大概可以看出样本属于不同类别的概率（但是实际上这些值并不是真实的概率，也就是说，他们之间的相对大小是有意义的，但是绝对值是无意义的）。交叉熵损失函数可以在Softmax的基础之上定义：$$L_i=-log(\frac{e^{f_{y_i}}}{\sum_j{e^{f_{y_j}}}})$$其中log里面的这部分：$$\frac{e^{f_{y_i}}}{\sum_j{e^{f_{y_j}}}}$$就是Softmax操作。可见交叉熵就是对Softmax的结果做log然后取相反数。交叉熵为什么这么定义，可以从两个角度来理解。首先从信息论的角度来看，在信息论中，两个分布p和q的交叉熵由下式定义：$$H(p,q) = -\sum_{x}p(x)log(q(x))$$回到交叉熵损失函数，假设p(x)是数据的真实分布，q(x)是电脑预测的分布，那么交叉熵损失函数就是希望这两个分布的交叉熵尽可能小。注意到，在交叉熵损失函数里并没有出现q(x)，那是因为对于样本$x_i$,p(x) = [0, …, 1, …, 0]，实际上已经隐含在式子中了(只出现了正确类别的那项，因为只有这项p(x)为1）。另外，p和q的交叉熵还可以表示为p的熵加上p、q之间的KL距离(Kullback-Leibler divergence)：$$H(p,q) = H(p) + D_{KL}(p||q)$$因为 H(p)为0，那么交叉熵实际上等于p和q之间的KL距离，这个距离表示的是两个分布之间的距离。总结一下，交叉熵损失函数希望的是实际分布p和预测分布q能够尽可能地接近。从另一个角度，概率论的角度看，有：$$P(y_i|x_i;W)=\frac{e^{f_{y_i}}}{\sum_j{e^{f_{y_j}}}}$$上式表示的是给定样本$x_i$和参数集合W，这个样本是真实类别$y_i$的概率。因此从概率的角度看，最小化正确类别的负的log似然，可以认为是在做极大似然估计（Maximum Likelihood Estimation, MLE）。首先来看Softmax函数在caffe2中的实现(有删减):// (1)void SoftmaxCPU( CPUContext&amp; context, const int N, const int D, const float* Xdata, float* Ydata, float* scale, const float* sum_multiplier, float* rowmax) &#123; math::RowwiseMax&lt;float, CPUContext&gt;(N, D, Xdata, rowmax, &amp;context); // Put the intermediate result X - max(X) into Y context.template Copy&lt;float, CPUContext, CPUContext&gt;(N * D, Xdata, Ydata); // (2) Subtract the max (for nomuerical reasons) math::Gemm&lt;float, CPUContext&gt;( CblasNoTrans, CblasNoTrans, N, D, 1, -1, rowmax, sum_multiplier, 1, Ydata, &amp;context); // (3) Exponentiation math::Exp&lt;float, CPUContext&gt;(N * D, Ydata, Ydata, &amp;context); math::Gemv&lt;float, CPUContext&gt;( CblasNoTrans, N, D, 1, Ydata, sum_multiplier, 0, scale, &amp;context); // (4) Do division for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; D; ++j) &#123; Ydata[i * D + j] /= scale[i]; &#125; &#125;&#125; (1) Softmax 函数的输入包括一个$N \times D$维的评分矩阵Xdata,其中N为batch size，D为类别数。Ydata是softmax的计算结果。 (2) 为了避免数值错误，可以先把每一个样本的评分都减去最大评分。其中 math::Gemm 是General matrix multiply 函数，可以计算两个矩阵相乘。这里是把Xdata减去每一行的最大值放到了Ydata里。 (3) 计算$e^{f_{y_i}}$ 和${\sum_j{e^{f_{y_j}}}}$ (4) 计算$\frac{e^{f_{y_i}}}{\sum_j{e^{f_{y_j}}}}$ 有了Softmax的输出结果，交叉熵只需把真实标签对应下的值求log并取相反数即可：for (int i = 0; i &lt; N; ++i) &#123; Ydata[i] = -log(std::max(Xdata[i * D + labelData[i]], kLOG_THRESHOLD())); &#125; 适用于回归的损失函数回归任务需要预测一个实数值，比如房价。此时通常用范数来定义损失函数，比如L1、L2范数等。 L2 Squared normL2平方范数描述的是预测值和实际值的L2范数距离,下面是对单个样本的计算公式：$$L_i=||f - y_i||_2^2$$ L1范数则是把各个维度的差异累加起来：$$L_i=||f - y_i||_1 = \sum_j|f_j - (y_i)_j|$$ 相比于L1范数，L2范数更适合求导，但是L1范数却更鲁棒。从优化方面看，L2范数会比Softmax、SVM loss难优化得多，因此要尽可能地将问题建模为分类问题求解。 其它损失函数除了分类和回归，还有多种属性的分类问题，每个样本可能同时拥有多种属性。这时需要对每一种属性训练一个2类的svm loss。另外，还有所谓的结构化预测问题(Structured prediction)，这里labels可以是图或者树的结构。以后有时间再学习这方面的内容吧。 正则化损失前面介绍的都是data loss，在实际的应用中，通常会再加上正则化损失：$$\lambda R(W)$$ 这里的函数R(W)可以是L2范数（和0向量的L2范数距离），称为L2 regularization$$\frac{1}{2}\lambda W^2$$这里加上的系数是为了求导方便。 也可以是L1范数，称为L1 regularization：$$\lambda|W|$$ 总结目前用的最多的损失函数是带正则化的SVM loss和Cross-Entropy loss，实际上这两种loss是很类似的。前者的loss有一个max的截断，后者更加连续。可以说在不同的场景下有各自的优缺点，遇到实际问题可以都试一试比较一下。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>损失函数</tag>
        <tag>SVMLoss</tag>
        <tag>SoftMax</tag>
        <tag>CrossEntropy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习有哪些组成部分]]></title>
    <url>%2F2017%2F11%2F23%2Fcomponents-of-machine-learning%2F</url>
    <content type="text"><![CDATA[从这篇博客开始，我打算写一系列关于深度学习的文章，旨在梳理深度学习的各个相关组成结构，并探索相应的实现细节。每篇文章可能只会涉及比较小的一个idea，并尽量用caffe2这个库去解读/实现。 什么是机器学习顾名思议，机器学习是让机器进行学习的一门学问。机器学习通过喂给电脑大量的先验知识，让电脑了解数据的分布规律，从而使得电脑具备对数据进行预测的能力。比如，给电脑喂大量带标签的图片（标签表明图片里是什么）之后，我们随便给一个电脑没有看过的图片，它就能够预测这个图片里面是什么。 总结成数学语言，对于由N个D维训练样本组成的集合 $x_i \in R^D$, 每个样本对应一个标签 $y_i$，其中 $i = 1 … N$, $y_i \in 1 … K$，K是数据的总的标签数。机器学习的目的是让电脑得出一个评分函数（score function）$f: R^D -&gt; R^K$, 这个函数可以把某一个训练样本映射为一个标签。评分函数通常写成下面的形式：$$s_i = f(w, x_i)$$即该函数是样本X的函数，w是这个函数的参数集合。不同的机器学习算法体现在评分函数的不同上。线性分类器的评分函数是一个线性函数，只带两个参数（斜率和偏移），SVM分类器的评分函数则是高维函数，至于神经网络乃至深度卷积神经网络的评分函数就够复杂了，参数可以达到数千万乃至上亿。 机器学习的组成结构通常在电脑完成学习之后，可以用评分函数对新的数据进行预测。但是学习的过程还需要代价函数，或者叫损失函数（Loss function）来辅助。在学习/训练的过程中，损失函数通常放在评分函数之后，以评分函数的输出和真实的标签为输入，计算出一个损失值。通过这个损失值指导评分函数对其参数进行调整。通过不断的学习，电脑就能够找到合适的一组权重参数，使得评分函数的输出值进入到损失函数能得到一个尽可能小的值。这个调整权重参数的过程实际上是最小化损失函数的过程，这里目前用的最多的是梯度下降算法。 总结一下，机器学习的结构可以分成三部分，第一部分是评分函数，用来模拟人的决策过程；第二部分是损失函数，用来衡量机器的决策和真实决策的差异；第三部分是最小化损失函数的过程，用来调整评分函数的权重。等到训练过程结束，我们便可以单独使用评分函数进行预测。 接下来的计划 …后续的blog将会围绕机器学习的这三部分进行，下面是初步拟定的大纲： Loss function(svm loss, softmax loss/cross entropy…) Stochastic gradient decent(batch sgd…) Backward propagation(chain-rule, subgradients…) Activation layer Weight initialization Full connected layer(gemm…) Convolutional layer Pool layer Normalization layer CNN case study(alexnet, googlenet, vggnet, resnet…) Upsample layer FCN LSTM SegNet U-Net fast-rcnn/faster-rcnn YOLO SDD 以上列出的是可能会涉及的概念，当然中间还会穿插一些关于影像识别方面的一些具体例子。所有的Blog代码都会基于caffe2来开发，这得益于caffe2的高度模块化设计，让我们可以不修改源代码也可以添加自定义的层和相关算法。另外caffe2不仅效率高，而且可以运行在多种设备之上，使得我们的学习代码可以具备工程应用的条件。接下来的所有代码都会放在caffe2_cpp_tutoria这个仓库中。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua 语言]]></title>
    <url>%2F2016%2F11%2F13%2Flua-language%2F</url>
    <content type="text"><![CDATA[最近在忙着做地理方面的机器学习的研究，把博客给荒废了。今天就把最近常用的Lua编程语言做些笔记，方便以后参考。 Lua 是一门动态类型的脚本语言，具有很强的拓展性，可以和C/C++进行交互。Lua的语法简单、运行十分高效，通常应用于嵌入式程序、C程序，当然也可以单独使用Lua进行程序设计。 安装 Lua windows使用 LuaDist 进行安装 linux curl -R -O http://www.lua.org/ftp/lua-5.3.3.tar.gztar zxf lua-5.3.3.tar.gzcd lua-5.3.3make linux test mac curl -R -O http://www.lua.org/ftp/lua-5.3.3.tar.gztar zxf lua-5.3.3.tar.gzcd lua-5.3.3make macosx test 安装完成后，你可以在命令行中输入 lua 命令进入解释器界面进行编码尝试；也可以在一个文本编辑器中书写代码，保存成文件，比如保存成test.lua，然后再命令行中输入 lua test.lua 执行文件中的代码。 下面就开始介绍 Lua 语言啦。 注释 单行注释 -- 两个短横线表示一个单行注释 块注释 --[[ 使用两个短横线和两个方括号 表示多行注释--]] 基本变量 nil表示值未定义 t = nil boolean t = false numberLua中所有的数都是double类型的 num = 42 string s1 = '通常用单引号表示字符串's2 = "双引号也可以表示字符串"s3 = [[ 两个方括号 表示多行的 字符串 ]] 流程控制 if 语句 if num &gt; 40 then print('over 40')elseif s ~= 'abc' then io.write('s is not equal to abc')else print('num &lt;= 40 and s == abc')end while 语句 while num &lt; 50 do num = num + 1end for 语句 for i = 0, 10 do print(i)endfor j = 100, 1, -1 do print(j)end and or 语句，类似于其它语言的三元操作符：a?b:c ans = aBoolValue and 'yes' or 'no' repeat until 语句 repeat print(num) num = num - 1until num == 0 方法(Functions)function fib(n) if n &lt; 2 then return n end return fib(n - 2) + bib(n - 1)end--闭包和匿名方法function adder(x) return function(y) return x + y endenda1 = adder(9)a2 = adder(36)print(a1(16)) --&gt; 25print(a2(64)) --&gt; 100-- 方法也是一种类型，可以被赋值f = function (x) return x * x end 表（Tables）Tables是Lua唯一的也是最重要的数据结构，Tables实际上是关联数列。Table中的元素都以键值对的形式组织。 -- 一般的键是字符串t = &#123;key1 = 'value1', key2 = false&#125;-- 字符串的键可以通过点操作取值print(t.key1) -- Prints 'value1'.--任何非nil的值都可以作为键u = &#123;['@!#'] = 'qbert', [&#123;&#125;] = 1729, [6.28] = 'tau'&#125;--通过方括号的形式去取值print(u[6.28]) -- prints "tau"-- 若不指定键，通常会用默认的int表示，通过这种方式可以表示数组v = &#123;'value1', 'value2', 1.21, 'gigawatts'&#125;for i = 1, #v do -- #v is the size of v for lists. print(v[i]) -- Indices start at 1 !! SO CRAZY!end Metatables and metamethods一个Table可以包含一个Metatable来重载操作符行为。下面显示了如何表示复数的相加：f1 = &#123;a = 1, b = 2&#125; -- Represents the fraction a/b.f2 = &#123;a = 2, b = 3&#125;-- This would fail:-- s = f1 + f2metafraction = &#123;&#125;function metafraction.__add(f1, f2) local sum = &#123;&#125; sum.b = f1.b * f2.b sum.a = f1.a * f2.b + f2.a * f1.b return sumendsetmetatable(f1, metafraction)setmetatable(f2, metafraction)s = f1 + f2 -- call __add(f1, f2) on f1's metatable 可以通过metatable来定义默认的键值对-- An __index on a metatable overloads dot lookups:defaultFavs = &#123;animal = 'gru', food = 'donuts'&#125;myFavs = &#123;food = 'pizza'&#125;setmetatable(myFavs, &#123;__index = defaultFavs&#125;)eatenBy = myFavs.animal -- works! thanks, metatable 类和继承Lua没有类的对象，但是可以通过Table和Metatable来构造。 Dog类Dog = &#123;&#125;function Dog:new() local newObj = &#123;sound = 'woof'&#125; self.__index = self return setmetatable(newObj, self)endfunction Dog:makeSound() print('I say ' .. self.sound)endmrDog = Dog:new()mrDog:makeSound() -- 'I say woof' Dog:new 和Dog:makeSound这种冒号调用方法的方式可以隐式地传递当前调用对象进入函数，也就是函数体中引用的self。 继承Dog类LoundDog = Dog:new()function = LoundDog:makeSound() local s = self.sound .. ' ' print(s .. s .. s)endseymour = LoundDog:new()seymour:makeSound() -- 'woof woof woof' LoudDog 得到了 Dog 的变量和函数，并且重新定义了makeSound这个函数。 ModulesModules用来分离和共享代码。Modules一般返回一个Table对象。 -- mymod.lualocal M = &#123;&#125;local function sayMyName() print('Hrunkner')endfunction M.sayHello() print('Why hello there') sayMyName()endreturn M 另一个文件可以调用mymod.lua这个模块 local mod = require('mymod') -- Run the file mod.lua.-- This works because mod here = M in mod.lua:mod.sayHello() -- Says hello to Hrunkner.-- This is wrong; sayMyName only exists in mod.lua:mod.sayMyName() -- error 最后，如果对 Lua 感兴趣，想进一步学习的话，可以下载 Programming in Lua 进行学习。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 属性]]></title>
    <url>%2F2016%2F09%2F26%2Fcss%2F</url>
    <content type="text"><![CDATA[颜色 color前景色 background-color背景色 opacity透明度 颜色指定的三种方式RGB、RGBA；16进制；hsl、hsla（hsl指定色调、饱和度以及明度）。 文本字体术语 衬线字体（SERIF）字符在笔画的末端有一些额外的装饰（称为称线）。通常打印长篇文本时使用衬线字体。包括 Georgia，Times，Times New Roman。 无称线字体（SANS-SERIF)字母拥有笔直的线条，设计更为简洁。屏幕分辨率要地于打印分辨率，因此当文本比较小时，屏幕上使用无衬线字体阅读起来会更清晰。包括 Arial， Verdana， Helvetica。 等宽字体（MONOSAPCE）每个字母的宽度都相同。因为可以精确地对齐，通常用于显示代码。包括 Courier， Courier New。 字体 font-family指定一组字体，以逗号隔开，如：body &#123; font-family: Geogia, Times, serif;&#125;h1,h2 &#123; font-family: Arial, Verdana, sans-serif;&#125;.credits &#123; font-family: &quot;Courier New&quot;, Courier, monospace;&#125; 如上所示，将通用字体名作为一类字体的结尾也是很常见的做法。 font-size可以以像素（px）、百分数(%)、或是EM值（em）为单位。1em相当于一个字母m的宽度。要保证字体以希望的大小出现，最好的方式就是以像素为单位对字体大小进行设置。 @font-face可以通过指定下载地址来获得计算机上没有的字体。 font-weight取值 normal 或 bold font-style取值 normal 或 italic 或 oblique。其中 italic 是文本以斜体显示；而 oblique 仅仅是把文本倾斜一个角度显示而已。 text-transform改变文本的大小写。取值 uppercase 或 lowercase 或 capitalize。 text-decoration可取以下值：none：把应用在文本上的装饰线去掉underline：文本底部增加一条实线overline：文本顶部增加一条实线line-through: 用一条实线穿过文字blink：使文本动态闪烁（会招人烦！） line-height行间距。一般而言，垂直的行间距应该要大于文字间距。 letter-spacing字距 word-spacing单词间距 text-align文字对齐方式。可取值 left， right， center， justify。 text-indent对首行文本进行缩进。 text-shadow创建投影。需要指定三个长度值和一种颜色。第一个长度值表明阴影向左或向右延伸的距离；第二个长度值表明阴影向上或向下延伸的距离；第三个长度值为可选项，用于指定投影的模糊程度；最后一项是投影的颜色值。 :first-letter伪元素，指定首字母。 :first-line伪元素，指定首行 p.intro:first-letter &#123; font-size: 200%;&#125;p.intro.first-line &#123; font-weight: bold;&#125; :link未访问过的链接 :visited访问过的链接 :hover光标悬停其上的元素 :active用户单击的元素 :focus占据焦点的元素 盒子每一个元素都是一个矩形的盒子。 width，height控制盒子大小 min-width，max-width限制盒子宽度 min-height, max-height限制盒子高度 overflow内容溢出盒子的处理方式：hidden，scroll border-width盒子边框宽度 border-style边框样式：solid, dotted, dashed, double, groove, ridge, insert, outset, hidden/none可以用下面的属性对各个方向的边框样式单独设置：border-top-styleborder-left-styleborder-right-styleborder-bottom-style border-color边框颜色。也可以对各个方向的边框分别设置颜色。 border同时指定边框的宽度，样式和颜色 p &#123; width: 250px; border: 3px dotted #0088dd;&#125; padding内边距：元素内容与元素边框之间的距离。可以用下面的属性分别指定各个方向上的内边距：padding-toppadding-rightpadding-bottompadding-left也可以用 padding 这个属性快速指定（以上、右、下、左的顺序） padding: 10px 5px 3px 1px; margin外边距：盒子之间的距离。不同方向的指定参照 padding。指定 left-margin 和 right-margin 分别为 auto 可以使盒子居中显示。 display允许将一个内联元素转换为块级元素，反之亦然。取值：inline：使块级元素表现得像内联元素。block：使内联元素表现得像块级元素。inline-block：使块级元素像内联元素那样浮动并保持其它块级元素的特征。none：将一个元素从页面上隐藏。页面上会像没有这个元素一样。 visibility从用户视线中隐藏盒子，但保留了盒子原来占用的空间。取值：hidden：隐藏元素。visible：显示元素注意和 display 的区别。 border-image设定边框图像 box-shadow在盒子周围添加投影 border-radius在盒子上创建圆角（指定一个半径）创建椭圆形（指定两个半径） 列表 list-style-type项目列表样式。对于无序列表，可以取值：none，disc，circle，square对于有序列表，可以取值：decimal， decimal-leding-zero，lower-alpha， upper-alpha， lower-roman， upper-roman list-style-image使用图片作为项目列表符号 list-style-position默认情况下，列表会缩进到页面中。该属性用于表示标记显示的位置，是在包含主题内容的盒子内部，还是在其外部：outside， inside。 list-style使用这个属性可以同时指定列表的位置和样式。 表格 width padding单元格与其内容之间的空隙 text-transform letter-spacing，font-size用于为表格标题内容增加额外的样式 border-top, border-bottom用于设置表格标题上方和下方的边框 text-align设置左右对齐 background-color用于交替改变表格行的背景颜色 :hover用户把光标停在某个单元格时高亮显示 empty-cells设置空单元格的边框，取值：show，hide，inherit border-spacing, border-collapse设置单元格之间的间隙 表单文本框样式 font-size用户输入文本大小 color文本颜色 background-color文本输入框颜色 border文本输入框边框 background-image为盒子增加背景图像 提交按钮样式 color控制文本按钮颜色 text-shadow显示3D效果文本 border-bottom使按钮下方边框稍微粗一点，从而使3D效果更逼真 background-color :hover鼠标悬停按钮之上 布局 position 三种用于控制页面布局的定位机制：普通流position:static 每个块级元素都换行显示，以至于页面中的每个项目都显示在前一个项目的下面。即使指定了盒子的宽度，并且也有足够的空间让两个元素并排显示，但是他们还是不会出现在一起。这是浏览器的默认行为。 相对定位position:relative 把一个元素从它在普通流中所处的位置进行上、下、左、右的移动。这种移动不会影响周围元素的位置，他们还是处于普通流中所处的位置。 通过制定 top，left，right，bottom 属性可以把一个元素以其在普通流中所处的位置为起点进行移动。p.example &#123; position: relative; top: 10px; left: 100px;&#125; 绝对定位position:absolute 绝对定位的元素的位置相对于它包含的元素。它完全脱离了普通流，也就是说不会影响到周围任何元素的位置。使用绝对定位的元素随着页面的滚动而移动。 盒子的位移属性 top，left，right，bottom 用于指定元素相对于它的包含元素应该显示什么位置。h1 &#123; position: absolute; top: 0px; left: 500px; width: 250px;&#125; 在上面的例子中，h1元素被定位于页面顶端并距离页面左侧边缘500像素的位置。 固定定位position:fixed 固定定位是绝对定位的一种形式，与相对于包含元素的定位不同，他是将元素相对于浏览器窗口进行定位。固定定位的元素不会影响周围元素的位置，而且当页面上下滚动时，它不会移动。 z-index当使用相对定位、固定定位或者绝对定位时，盒子是可以重叠的，这时可以使用 z-index 元素指定层次。数值越大，元素的层次越靠前。 floatfloat 属性允许将普通流中的元素在它的包含元素内尽可能地向左或向右排列。位于包含元素中的其它内容会在浮动元素的周围流动。 clear用来清楚某一侧的浮动元素，取值：left，right，both，none 可以用并排的float元素创建并排布局 .column1, .column2, .column3 &#123; width: 300px; float: left; margin: 10px;&#125; 选择器 通用型选择器 * &#123;&#125; 类型选择器 h1, h2,h3 &#123;&#125; 类选择器 .note &#123;&#125;p.note &#123;&#125; ID选择器 #intro &#123;&#125; 子元素选择器 li&gt;a &#123;&#125; 后代选择器 p a &#123;&#125; 相邻兄弟选择器 h1+p &#123;&#125; 普通兄弟选择器 h1~p &#123;&#125;]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 标签]]></title>
    <url>%2F2016%2F09%2F24%2Fhtml-tags%2F</url>
    <content type="text"><![CDATA[页面结构 bodybody 元素中的所有内容都会显示在浏览器的主窗口中 head包含页面的一些信息，比如标题等 title页面标题，通常位于 head 内。 文本结构化标签结构化标签会影响网页的结构。 h1, h2, h3, h4, h5, h6标题 p段落 b粗体 i斜体 sup上标 sub下标 br换行 hr分割线 语义标签语义标签不影响网页的结构，却可以为页面添加额外的信息。 strong表示十分重要。默认浏览器中显示为粗体。 em起强调作用。默认浏览器中显示为斜体。 blockquote标记较长的引用。默认浏览器会对 blockquote 中的内容进行缩进。 q标记较短引用 abbr缩写。通过指定 title 属性来指明全称。鼠标移上去时会动态显示。 cite标明引用来源。浏览器会显示为斜体。 dfn解释新术语 address包含网站设计者的联系详情。通常显示为斜体。 ins显示已经插入到文档中的内容。通常带有下划线。 del显示已经从文档中被删除的内容。通常带有删除线。 s显示不准确或不相关却不应当予以删除的内容。通常带有从中穿过的线条。 列表 ol有序列表，其中的每个项目用 li 元素表示。 ul无序列表，其中的每个项目用 li 元素表示。 dl定义列表，用成对的 dt 和 dd 元素来表示被定义的术语及相应的定义。 链接 a用 href 属性来指明要链接的目标页面。当链接到另一个网站时，href 的值必须是绝对 URL；当链接到同一网站的目标页面时，href 的值可以是相对 URL。同一个网站不同页面的相对 URL 类似于文件系统中不同文件的相对位置，实际上，二者没有本质区别。 mailto:在 a 标签中的 href 属性中指定 mailto: 后跟一个邮箱名称时，单击链接会启动 email 程序，并自动添加连接中指定的 email 地址为收件人。 target在 a 标签中指定 target 属性为 _blank 时可以在新窗口中打开链接。一般情况下，要尽量避免在新窗口中打开链接，除非是跳转到其它的网站。 #id在 a 标签中的 href 属性中用 # 后跟某元素的 id 时，会跳转到页面内的这个元素。在跳转到其它页面时，如果在原来的 URL 后用这种方式指定元素，也可以跳转到其它页面的某个元素。 图像 imgimg 标签要指定几个属性：src：图像地址alt：对于图像的说明titile：图像名称，鼠标悬停在图像上方时会显示height,width: 图像大小应该根据图像在网页上显示的大小来保存图像；照片最好保存为JPEG格式。 figure用来包含图像以及对图像的说明。其中图像说明用 figcaption 来指定。 &lt;figure&gt;&lt;img src=&quot;images/nice.jpg&quot; alt=&quot;beautiful scene&quot;&gt;&lt;br /&gt;&lt;figcaption&gt;How beautiful it is!&lt;/figcaption&gt;&lt;/figure&gt; 表格 table创建表格。 tr表格内的每一行。 td表格内每一行内的每一个单元格。通过指定 colspan 或者 rowspan 单元格可以跨列或者跨行。 th和 td 用法一样，但它的作用是表示列或行的标题。用 scope 的属性来指定（可以赋值为 row 或 col）。 thead表格的内容应放在 thead 中。 tbody表格的主体部分应放在 tbody 元素中。 tfoot表格的脚注应放在 tfoot 元素中。 &lt;table&gt;&lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;列标题一&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;列标题二&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt; &lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;行标题一&lt;/th&gt; &lt;td&gt;列值一&lt;/td&gt; &lt;td&gt;列值二&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;行标题二&lt;/th&gt; &lt;td&gt;列值一&lt;/td&gt; &lt;td&gt;列值二&lt;/td&gt; &lt;th scope=&quot;row&quot;&gt;行标题二&lt;/th&gt; &lt;/tr&gt; &lt;!-- 其它行 ... --&gt;&lt;/tbody&gt;&lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;表格脚注&lt;/td&gt; &lt;tr&gt;&lt;/tfoot&gt;&lt;/table&gt; 表单 form表单位于 form 元素中。action 属性来指定响应的 URL。method 来指定提交的方式：get 或 post。 添加文本 input type=”text”添加单行文本。 input type=”password”添加隐藏单行文本。 textarea添加多行文本。 进行选择 input type=”radio”单选按钮。 input type=”checkbox”复选框。 select下拉列表框。通过 option 子标签来设置选项。通过设置 multiple 选项可以设置多选框。 提交表单 input type=”submit”提交按钮。 input type=”image”图像提交按钮。 上传文件 input type=”file”上传文件。 按钮 button可以结合文本和图像。 标签 label可以用两种方式使用标签：1. 将文本说明和表单输入框全部包围起来；2. 与表单控件分开，但是通过 for 属性来指定表单空间的 id。 组合表单 fieldset组合多个控件；会有一个外边框围起来。 legend可以指定多个控件的组合的标题。 其它控件 input type=”date”日期控件。 input type=”email”邮箱输入。 input type=”url”网页地址输入。 input type=”search”搜索输入。 &lt;form action=&quot;http://www.example.com/review.php&quot; method=&quot;get&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;你的详细信息：&lt;/legend&gt; &lt;label&gt;Name: &lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;30&quot; maxlength=&quot;100&quot;&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt;Email: &lt;input type=&quot;email&quot; name=&quot;email&quot; size=&quot;30&quot; maxlength=&quot;100&quot;&gt; &lt;/label&gt; &lt;br /&gt; &lt;/fieldset&gt; &lt;br /&gt; &lt;fieldset&gt; &lt;legend&gt;你的调查：&lt;/legend&gt; &lt;p&gt; &lt;label for=&quot;hear-about&quot;&gt;你是怎么知道我们的？&lt;/label&gt; &lt;select name=&quot;referrer&quot; id=&quot;hear-about&quot;&gt; &lt;option value=&quot;google&quot;&gt;Google&lt;/option&gt; &lt;option value=&quot;friend&quot;&gt;朋友&lt;/option&gt; &lt;option value=&quot;other&quot;&gt;其它&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; 你会继续来访吗？ &lt;br /&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;rating&quot; value=&quot;yes&quot;/&gt; 是的 &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;rating&quot; value=&quot;no&quot;/&gt; 不会 &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;rating&quot; value=&quot;maybe&quot;/&gt; 也许 &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;comments&quot;&gt;想对我们说的：&lt;/label&gt; &lt;br /&gt; &lt;textarea rows=&quot;4&quot; cols=&quot;40&quot; id=&quot;comments&quot;&gt; &lt;/textarea&gt; &lt;/p&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;subscribe&quot; checked=&quot;checked&quot; /&gt; 订阅邮件 &lt;/label&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/fieldset&gt;&lt;/form&gt; 其它 白色空间折叠：浏览器忽视空白和断行。 id 特性：同一个页面内元素 id 是唯一的。 class 特性：多个元素可以属于一个 class 。 某些元素总是会另起一行，称为块级元素，比如 h1，p， ul 以及 li 等。 有些元素出现时总是和邻近的元素在同一行，称为内联元素，比如 a，b，em 以及 img 等。 div 元素可以将文本和元素集中在一个块级元素中。 span 元素就像是 div 元素的内联版本。 iframe 内联框架。页面内的一个小窗口。 meta 元素用来指定页面信息。如： &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页面的信息&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;个人博客&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;个人 博客 地图&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;nofollow&quot; /&gt; &lt;meta http-equiv=&quot;author&quot; content=&quot;atlas&quot; /&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 23 Apr 2017 23:12:34 GMT&quot; /&gt; &lt;/head&gt;&lt;/html&gt; 转义字符 小于号：&lt; &amp;lt; 大于号：&gt; &amp;gt; And符号：&amp; &amp;amp; 双引号：&quot; &amp;quot; 美分符号：&cent; &amp;cent; 英镑符号：&pound; &amp;pound; 日元符号：&yen; &amp;yen; 欧元符号：&euro; &amp;euro; 版权符号：&copy; &amp;copy; 注册商标：&reg; &amp;reg; 商标：&trade; &amp;trade; 左单引号：&lsquo; &amp;lsquo; 右单引号：&rsquo; &amp;rsquo; 左双引号：&ldsquo; &amp;ldsquo; 右双引号：&rdsquo; &amp;rdsquo; 乘号：&times; &amp;times; 除号：&divide; &amp;divide;]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机中的数学二：数论和加密算法]]></title>
    <url>%2F2016%2F09%2F15%2Fnumber-theory-and-rsa-algorithm%2F</url>
    <content type="text"><![CDATA[当我们使用 git 同步代码，ssh 远程登录虚拟机、使用数字签名、加密哈希函数以及电子支付系统时，都会用到公钥加密系统，而支撑起公钥加密系统的理论便是数论。 数论是关于整数的理论，首先来了解一些基本的概念和理论，然后再看看前人为实现安全加密做出的努力，最后再介绍现在广泛使用的 RSA 公钥加密算法。 整除定义：a 整除 b，当且仅当存在某个整数k，使得 $ak = b$。通常用符号 $a | b$ 来表示 a 整除 b。根据定义，如果 $a | b$，那么 b 就是 a 的整数倍。从这个定义可以得出，任何整数都可以整除 0。 关于整除的一些引理 如果 $a | b$，那么对于任意 c，都有 $a | bc$ 如果 $a | b$ 并且 $b | c$， 那么 $a | c$ 如果 $a | b$ 并且 $a | c$，那么对于任意 s 和 t 都有 $a | sb + tc$ 对于任意 $c \neq 0$, $a | b$ 当且仅当 $ca | cb$ 当无法整除的时候 …整除定理：令 n 和 d 为整数且$d \gt 0$，存在唯一的一对整数 q 和 r，使得： $$n = q \cdot d + r \;AND\; 0 \le r \lt d$$ 其中 q 称为 n 被 d 除的商，而 r 称为 n 被 d 除的余数。接下来我们用 $qcnt(n, d)$ 和 $rem(n, d)$ 分别表示这两者。举个栗子，$qcnt(2716, 10) = 271$ , $rem(2716, 10) = 6$，因为 $2716 = 271 * 10 + 6$ 最大公约数a 和 b 的最大公约数是指能同时整除 a 和 b 的最大整数，通常用符号 $gcd(a,b)$表示。（gcd 是 greatest common divisor 的缩写）。比如，$gcd(18,24) = 6$ 最大公约数和线性组合定理：a 和 b 的最大公约数是 a 和 b 可能的线性组合中最小的一个。比如，54和44的最大公约数是4，显然4是52和44的一个线性组合： $$6 \cdot 52 + (-7) \cdot 44 = 4$$ 并且，52和44的其它线性组合没有比4更小的。 推论：一个整数是 a 和 b 的线性组合，当且仅当它是 $gcd(a,b)$ 的倍数推论：假设我们有两个容量分别为 a 和 b 的容器，每个容器里能准确量出的水量永远是 a 和 b 的线性组合，也即是 a 和 b 的最大公约数的倍数。 最大公约数的性质 每一个能整除 a 和 b 的数都能整数 $gcd(a,b)$ 对于任意 $k&gt;0$, 都有 $gcd(ka,kb) = k \cdot gcd(a,b)$ 如果 $gcd(a,b) = 1$，并且 $gcd(a,c) = 1$，那么 $gcd(a, bc) = 1$ 如果 $a | bc$，并且 $gcd(a,b) = 1$，那么 $a | c$ $gcd(a, b) = gcd(b, rem(a, b))$ 其中第5点性质需要特别注意，它指导我们如何快速地计算两个数的最大公约数。比如：$$gcd(28, 21) = gcd(21, rem(28,21)) = gcd(21, 7) = gcd(7, rem(21, 7)=gcd(7,0) = 7$$ 算术基本定理算术基本定理：每一个正整数都可以写成唯一的由质数相乘的形式：$$n = p_1 \cdot p_1 \cdot p_2 \cdot \cdot \cdot p_j \; (p_1 \lt p_1 \lt p_2 \cdot \cdot \cdot \lt p_j)$$ 这个定理告诉我们，每一个正整数都可以由一组质数相乘得到。 求余运算同余的定义：a 和 b 对 n 做求模操作是同余的，当且仅当 $n | (a - b)$，这可以写成：$$a\equiv b\pmod n$$ 显然，当 a 和 b 的差能被 n 整除，那么 a 和 b 对 n 求模就没差异了，因为求模过程中要减去尽可能多的 n，而 a，b刚好相差整数个 n。 比如，$29 \equiv 15 \pmod 7$，因为 $7 | (29 - 15)$ 同余和余数之间的关系：$a\equiv b\pmod n$ 当且仅当 $rem(a, n) = rem(b, n)$ 另一个推论：$a \equiv rem(a, n) \pmod n$下面是一些同余的其它性质： $a \equiv a \pmod n$ 如果 $a \equiv b \pmod n$，那么 $b \equiv a \pmod n$ 如果 $a \equiv b \pmod n$ 并且 $b \equiv c \pmod n$，那么 $a \equiv c \pmod n$ 如果 $a \equiv b \pmod n$，那么 $a + c \equiv b + c \pmod n$ 如果 $a \equiv b \pmod n$，那么 $ac \equiv bc \pmod n$ 如果 $a \equiv b \pmod n$ 并且 $c \equiv d \pmod n$，那么 $a+c \equiv b+d \pmod n$ 如果 $a \equiv b \pmod n$ 并且 $c \equiv d \pmod n$，那么 $ac \equiv bd \pmod n$ 质数求模算术乘法逆元数 x 的乘法逆元表示为 $x^{-1}$，且有$$x \cdot x^{-1} = 1$$有一个例外是0没有逆元。实际上，乘法逆元是作用于实数域中的，比如 $3 * \frac 1 3 = 1$，而一个整数的逆元不可能还是一个整数。 然而，在求模运算中，整数的逆元还可能是整数！比如，假设5是模数，那么 3 就是 7 的乘法逆元，因为：$$7 \cdot 3 \equiv 1 \pmod 5$$ 事实上，所有以5为模数，和3同余的数都是7的乘法逆元。 引理：如果 p 是质数，并且 k 不是 p 的整数倍，那么以 p 为模数，k 存在乘法逆元。 相消实数算术的一个特点是可以消除公约数，换句话说，如果 $m_1k=m2k$，且 $k \neq 0$，那么我们可以消去 k，得到 $m_1 = m_2$。然而，在求模算术中，消除公约数却是不允许的，比如：$$2\cdot3 \equiv 4 \cdot 3 \pmod 6$$消除3，上式就不成立了。然而，当模数是质数时，消除却是成立的。 引理：假设 p 是一个质数，并且 k 不是 p 的倍数。那么：如果 $ak \equiv bk \pmod p$，就有 $a \equiv b \pmod p$ 引理：假设 p 是一个质数，并且 k 不是 p 的倍数。那么序列： $$rem(1\cdot k, p), rem(2\cdot k, p), …, rem(((p-1)\cdot k), p)$$ 是下面序列的一个排序：$$1, 2, …, (p - 1) $$ 也即这两个序列相等，只是元素的顺序不同。 费马小定理费马小定理：假设 p 是一个质数，k不是 p 的倍数，那么：$$k^{p-1} \equiv 1 \pmod p$$ 根据费马小定理，有：$$k^{p-2} \cdot k \equiv 1 \pmod p$$因此，$k^{p-2}$一定是 k 的乘法逆元 任意模量的算术互质数 a 和数 b 是互质的，当且仅当 $gcd(a, b) = 1$。比如，8和15是互质的，因为二者的最大公约数为1。注意到，除了质数的倍数，所有整数和某个质数 p 都是互质的。 引理：令 n 是一个正整数。如果 k 与 n 互质，那么存在一个整数 $k^{-1}$使得：$$k \cdot k^{-1} \equiv 1 \pmod n$$从这个引理可以看出，不需模数是质数，只要 k 和 n互质，就可以安全地进行消去操作。 推论：假设 n 是一个正整数并且 k 与 n 互质，如果$$ak \equiv bk \pmod n$$那么$$a \equiv b \pmod n$$ 引理：假设 n 是一个正整数并且 k 与 n 互质。那么序列： $$rem(k_1\cdot k, n), rem(k_2\cdot k, n), …, rem((k_r\cdot k), n)$$ 是下面序列的一个排序：$$k_1, k_2, …, k_r$$ 也即这两个序列相等，只是元素的顺序不同。 欧拉定理欧拉函数 $\phi(n)$表示集合${1,2,…,n}$中和 n 互质的数的个数。比如$\phi(7) = 6$，因为1，2，3，4，5，6与7是互质的。 定理：对任意的数 n， 如果$p_1,p_2,…,p_j$ 是 n 的互不相同的质因子，那么：$$\phi(n) = n(1-\frac 1 p_1)(1-\frac 1 p_2)\cdot \cdot \cdot (1-\frac 1 p_j)$$ 推论：令 $n = pq$，p，q 为不同的质数，那么 $\phi(n) = (p - 1)(q - 1)$ 欧拉定理：假设 n 是一个正整数并且 k 与 n 互质，那么：$$k^{\phi(n)} \equiv 1 \pmod n$$ 实际上，费马小定理是欧拉定理中的n是质数时的的一个特例，当 n 为质数时有：$$\phi(n) = n - 1$$ 图灵的故事图灵是计算机领域的天才，也是他最早提出用数论来解决加密传输的问题。当时它未把文章发表，只留有代码，下面我们就看看众多的计算机学家如何从图灵的代码开始，一步步完善，最终形成如今成熟加密系统的过程。 图灵代码（版本1.0）实现加密传输的第一个问题是要把文字信息转换为整数，这样我们就可以对整数应用数学操作。这个过程不是加密的过程，因此可以使用一些简单的办法，比如把每个字符或者汉子用一个数字表示，所有字符表示的数字串联在一起就形成了一个很大的整数。比如，“今晚两点行动”可以用下面的方法编码： 今 晚 两 点 行 动 22 09 03 20 15 25图灵的代码需要信息被编码成一个质数，而实际上，通过在原有的整数后面添加几位数可以达到这个要求，这个算法已经比较成熟。信息被编码成质数后，加密和解密的过程按照下面的方式进行。假设 m 是未加密的信息，$m^*$是加密后的信息，k是密钥： 开始前 信息的发送和接收方在某个阴暗的街角确定一个密钥k，k是一个很大的质数。 加密 信息的发送方通过下面的方式加密信息：$$m^* = m \cdot k$$ 解密 信息的接收方通过下面的方式还原信息：$${m^* \over k} = {m \cdot k \over k} = m$$ 图灵算法加密过后的数是原来的质数与一个很大的质数密钥相乘的结果，是一个很大的数，要想直接因式分解这个数得到密钥k是很难得一件事，然而，使用数论的技巧却可以很容易打破这个系统。假设我们得到了两个经过加密的信息： $$m_1^\ast= m_1 \cdot k \;and\; m_2^\ast= m_2 \cdot k$$ 那么$m_1^\ast$$和$$m_2^\ast$的最大公约数就是k！从前面可以知道，k可以非常快速地求出来！ 图灵代码（版本2.0）开始前 信息的发送和接收方确定一个很大的质数 p, p可以是公开的（p将作为我们的模数）。另外，他们还偷偷地确定一个私有密钥$k\in {1,2,…,p-1}$ 加密 信息 m 可以是集合${0,1,2,…,p-1}$中的任意一个数，并且 m 不需要是质数。信息的发送方通过下面的方式加密信息：$$m^\ast = rem(mk, p)$$可以看出，加密过程不是简单的求积，而是将求积的结果取了模 解密 解密的过程需要用到前面提到的求模代数里同余和乘法逆元的知识。根据余数的定义，我们知道加密后的信息是原信息与质数 k 相乘以 p 为模数的余数，即：$$m^\ast = rem(mk, p) = mk \pmod p$$现在我们想要从$m^*$求出 m，自然想到如果在上式两边同乘以k的逆元，那么就可以消去和 m 相乘的 k，从而得到 m。假设 k 的乘法逆元是$k^{-1}$（之所以要假设，是因为k的乘法逆元可能不存在），那么有$$m^\ast k^{-1} \equiv mk\cdot k^{-1} \equiv m \pmod p$$ 由于 $m \in {1, 2, …, p - 1}$，有$$m = rem(m^\ast k^{-1}, p)$$ 实际上，这个思路的公钥k也极容易泄露出去！我们需要知道一对加密前和加密后的信息就可以窃取公钥。下面是具体的做法：假设加密前的信息 m 和加密后的信息 $m^*$ 被泄露，根据加密过程，有：$$m^\ast = rem(mk, p)$$即$$m^\ast = mk \pmod p$$由于 p 是一个质数，所以 m 与 p 互质，即：$$gcd(m, p) = 1$$由于 m 和 p 已知，可以算出 m 以 p 为模数的乘法逆元 $m^{-1}$，使得$$m\cdot m^{-1} \equiv 1 \pmod p$$ 当我们把已知的 $m^*$ 和 m 的乘法逆元相乘就有：$$m^\ast \cdot m^{-1} \equiv km \cdot m^{-1} \equiv k \pmod p$$看到了吗？我们得到了密钥 k ！只要我们继续算出 k 以 p 为模数的乘法逆元，就可以解密任何信息！ RSA 算法RSA 公钥加密算法是1977年MIT发明的，是目前使用最广泛的加密算法，很难被窃取，它不需要交换私钥，只要数据接收者自己生成一对公钥和一对私钥，任何人都可以使用接收者发布的公钥加密信息，接受者然后使用只有它自己知道的私钥进行解密。 开始前 信息接收方使用下面的方式创建一对公钥和一对私钥 生成两个不同的质数，p 和 q。由于它们要用来生成私钥，因此必须要藏好。 让 n = pq。n 将作为公钥对的一部分，由于要分解两个大质数的乘积十分困难，因此p和q很难被破解。 选择一个整数 e 使得 $gcd(e, (p-1)(q-1)) = 1$。公钥对就是(e, n),可以被广泛分发。 计算 d，使得 $de \equiv 1 \pmod {(p-1)(q-1)}$。私钥对就是(d, n),必须要藏好。可以看出，整数 e 和 d 是以 (p-1)(q-1) 为模的乘法逆元 加密 给定一个信息 m，发送方首先检查 $gcd(m, n) = 1$,接着用公钥对信息进行加密：$$m^*=rem(m^e,n)$$ 解密 使用私钥把加密的信息还原回去：$$m=rem({m^\ast}^d, n)$$ 现在我们证明为了什么可以这么还原回去：根据加密过程知：$$m^\ast = rem(m^e,n) \equiv m^e \pmod n$$即$$m^\ast \equiv m^e \pmod n$$两边同时d方：$${m^\ast}^d \equiv m^{ed} \pmod n$$由于 e 与 d 互质，根据最大公约数和线性组合的关系知存在 r 使得：$$e\cdot d = 1 + r(p - 1)(q - 1)$$代入到上式有：$${m^\ast}^d \equiv m^{1 + r(p - 1)(q - 1)} \pmod n$$又因为 $n = pq$，根据费马小定理，有$$m^{p-1} \equiv 1 \pmod p$$$$m^{q-1} \equiv 1 \pmod q$$$${m^\ast}^d \equiv m^{1 + r(p - 1)(q - 1)} \pmod p$$$${m^\ast}^d \equiv m^{1 + r(p - 1)(q - 1)} \pmod q$$因此$${m^\ast}^d \equiv m \pmod p$$$${m^\ast}^d \equiv m \pmod q$$即$$p | {m^\ast}^d - m$$$$q | {m^\ast}^d - m$$$$pq | {m^\ast}^d - m$$所以$${m^\ast}^d \equiv m \pmod n$$最后便得到了$$m=rem({m^\ast}^d, n)$$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>加密算法</tag>
        <tag>RSA 算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用深度学习来探索地球，你信吗？]]></title>
    <url>%2F2016%2F09%2F03%2Fdeep-learning-intro%2F</url>
    <content type="text"><![CDATA[最近深度学习在计算机视觉领域取得了巨大的突破，更是随着AlphaGo与李世石的大战被普通老百姓所津津乐道。传统的遥感影像识别势必会在深度学习的影响下向前进一步发展，用深度学习来探索地球在不远的将来也将成为现实。 什么是深度学习深度学习实际上依赖的是深度神经网络。最近在计算机视觉上取得重大突破的是一种称为深度卷积神经网络的结构。科学研究表明，人的大脑里面有成百上千亿个神经元，这些神经元组成的网络支持着大脑的识别、分析等活动。深度卷积神经网络正是对大脑神经元结构的一种仿生工程。 拿图像识别为例。假设墙上挂有一副画，我们观察这幅画时，图像通过反射的光线进入到眼睛的成像系统，进而传给V1结构，V1结构包含大量的神经元，然后进入V4结构识别复杂的纹理，最后到达大脑皮层得出识别结果。 大脑在识别这幅画的时候，是以一种分层的方式来逐步识别的，比如我们可能最开始注意到这是一幅森林的图像，然后再注意到图像里的一些比较锐利的线段、细微的纹理变化等等。最后我们就可以一一识别图像里的物体，比如树木、动物等。 受人脑识别图像的启发，深度卷积神经网络也是由许多神经元组成，并且神经元分层排布。把图像里的所有像素作为输入，每一层的神经元都会去观测图像里的不同模式的特征，层数越深，观测的特征就越抽象，因为下一层的观测是在上一层观测的基础之上进行的。到最后一层，神经网络也被设计为输出图像里的物体类别。 在使用神经网络分类之前，要使用大量的样本数据去训练神经网络，经过训练的神经网络知道哪些特征（或者特征的组合）对于分类的作用最为显著，在输入一个新的图像时，就可以用学习到的特征对图像进行分类。 上图表示的是深度卷积神经网络识别图像的过程。最左边的鸟类图像是输入，最右边一层输出这个图像分别属于哪些类别的概率，从图中可以看出，这个图像属于bird这个类别的概率最大，说明神经网络成功识别出了图像。二者中间的许多层就是神经网络识别出来的不同的特征，在上图中，只把每层中最显著的10个特征可视化出来，实际上每一层的特征数量要远远大于10个。可以看出，层数越深，识别出来的特征就越抽象，这符合大脑的认知模式。 深度卷积神经网络之所以能取得媲美人类大脑的分类精度，在于它和人脑一样，可以同时观测图像里不同模式的特征，并且分层处理。而传统的图像分类手段只是采取单一的特征去分类，因此精度远不如深度神经网络。为了让大家理解深度卷积神经网络同时观测的特征之多，我们可以做一个简单的计算：假设深度卷积神经网络第一个卷积层观测了12个特征，第二个卷积层在上一个卷积层的基础上观测了28个特征，那么总共就是28x12=336个特征，如果第三个卷积层在上一个卷积层的基础上观测128个特征，那么总共就是336x128=43008个特征……而现在最多的深度卷积网络已经超过了上百层，可想而知观测的特征是极其庞大的，所以说用“上帝之眼”来形容深度卷积网络识别图像的过程一点都不为过。而这也是深度卷积网络获得成功的关键所在。在这么多特征中，总能找到能够很好分类图像的显著特征。 深度学习在影像识别中的应用传统的影像解译主要是根据影像中的色调、几何形态、纹理等特征来识别物体，而深度学习可以自动地观测数量庞大的特征来进行识别。遥感影像和普通的图片相比有优点也有缺点，优点是遥感影像不局限于普通彩色图片的RGB三个波段，越多的波段能够观测的特征就越多，也就越容易进行识别；而缺点则是遥感影像的分辨率一般没有图片那么高，但是现在随着越来越多的高精度传感器被发射升空，未来这个缺点将会被逐步克服。 借助深度学习网络，我们就可以自动化地对影像进行识别、甚至是搜索。下面是我在公司做的一个 demo 视频： 你也可以尝试这个交互demo来识别你感兴趣的地区。 除了分类，深度卷积神经网络还可以对原始图像进行分割。下面的demo可以从你选择的矩形范围内分割出其中的建筑出来。 如果我们能够对遥感影像进行分类和分割，那可以应用在哪里呢？ 首先是识别，这个应用场景是我们要寻找某个区域内的地物的时候，比如马航失事飞机的搜索、战时敌军机场的寻找等等。除了简单的搜索，还可以进行相似地物的搜索，正如上面分类 demo 展示的，当你选中一个地物时，我们可以搜索出和这个地物相似的其它地物。 其次是数据采集，矢量地图往往无法包含所有要素信息，并且更新间隔较长。如果能够从卫星影像中提取出矢量信息，补充到矢量数据库中，则可以极大减少人力采集数据的成本和数据更新的时间。比如，上面的建筑分割 demo ，我们可以很容易通过分割的方式统计某个城市建筑的面积。将来，如果分割精度进一步提高，完全可以自动化地提取全国的建筑矢量图层。 最后是监控，卫星在空中每天围绕着地球转，利用它拍摄的影像来监控目标是十分合适的。比如，监控工地的建设进度、城市建成区的拓展、农作物的生长情况、河流的萎缩情况以及野生动物的活动等等，而这一切都要建立在影像自动识别的前提之下。 当然，这里列出的并不完全，可以利用影像去做的事情还有更多！]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>影像识别</tag>
        <tag>深度卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机中的数学一：如何去证明]]></title>
    <url>%2F2016%2F08%2F29%2Fpropositions%2F</url>
    <content type="text"><![CDATA[计算机领域中的许多问题往往需要用数学模型和方法来解决，而数学的独特的证明方式在其中起着核心的作用。 简单来说，证明是一种建立事实的方法。然而，就像“美丽”这个词一样，“事实”有时候也是因人而异的：在法官眼中，事实得由证据来决定；在商界，事实可能由一个可信赖的人或是组织或仅仅是你的 boss 指定；在物理或是生物领域，事实由实验来确定；在哲学中，事实如“我思故我在”这句名言般缥缈。 当然，数学有它自己对于证明的定义。 数学意义上的证明数学上证明是从一组基本的公理出发，通过一系列逻辑推理最终得到待证明的命题。 这个定义由三个核心组成，分别是命题、逻辑推理和公理。本文先介绍命题。其余两个后续文章会继续介绍。 命题生活中我们也常常会提到命题这个词，命题实际上就是一个陈述语句，只不过命题这个陈述语句要么是对的，要么是错的。如果一个陈述语句无法判断对错，那么就不是命题。比如，“你喜欢数学吗？”这句话就不是命题。 下面是两个命题： 命题1： 2 + 3 = 5命题2： 1 + 1 = 3 复合命题单个命题比较简单，如果把多个命题通过“非”， “与”， “或”， “如果-那么”等词连接起来就成了复合命题。下面的命题就是由三个命题P、Q和R组合而成的： 如果 P 与 Q， 那么 R 如果已知单个命题的真假、根据不同的连接词就可以得出复合命题的真假。下面用真值表来表达。 “非”, “与”, 和“或” P 非 P T F F T P Q P 与 Q T T T T F F F T F F F F 从上表可以看出，命题 “P 与 Q” 仅当 P 和 Q 都是真时才为真。 P Q P 或 Q T T T T F T F T T F F F 命题 “P 或 Q” 只要 P 和 Q 有一个为真就为真。而如果想排除掉 P 和 Q 共同为真的情况，可以使用 异或 连接词： P Q P 异或 Q T T T T F T F T T F F F “如果-那么”前面三个连接词比较容易理解，而“如果-那么”则不太容易理解。先看真值表 P Q 如果 P 那么 Q T T T T F F F T T F F T 我们用一个具体点的命题来验证上面的结论： 如果黎曼猜想是对的，那么对于每个实数 $x$，都有 $x^2 \geq 0$ 黎曼猜想是一个著名的未解问题，因此命题 P 的真假未知，但是这并不妨碍我们判定上面这个命题是真的。也就是说，无论 P 是真的还是假的，上述命题都是真的。 有点不可思议？那我们再来看一个更极端的例子： 如果猪可以飞，那么你可以理解切比雪夫不等式 实际上，你可不可以理解切比雪夫不等式和猪可不可以飞没有半毛钱关系！不管猪可不可以飞，这个命题都是真的。 总之，命题“如果 P 那么 Q”是真的情况有两种，要么Q是真的，要么P是假的。 当且仅当这个比较容易理解，“P 当且仅当 Q” 即意味着P和Q是等价的。 下面是一个例子：$$x^2 - 4 \geq 0 \quad 当且仅当\quad |x| \geq 2$$ P Q P 当且仅当 Q T T T T F F F T F F F T 数学符号在数学中，往往用符号替换英语，上述的几种连接词可以用下面的符号表示： 英语 符号 非 P $\lnot{P}$ P 与 Q $P\land{Q}$ P 或 Q $P\lor{Q}$ 如果 P 那么 Q $P\implies{Q}$ P 当且仅当 Q $P\iff{Q}$ 逻辑上相等的命题实际上，与命题 “如果 P 那么 Q” 相等的命题是“如果非 P 那么非 Q”。这两个命题有着相同的真值表。 注意 “如果 P 那么 Q” 与 “如果 Q 那么 P” 并不相等。只有当 “P 当且仅当 Q” 为真时二者才相等。 计算机程序中的命题逻辑了解了上述的复合命题的判定方法，很容易知道下面这两行程序表述的命题是相等的，而有时候我们可能会写成第一行的样子，导致程序运行时间和程序代码变长。 if (x &gt; 0 || (x &lt;= 0 &amp;&amp; y &gt; 100)) if (x &gt; 0 || y &gt; 100) 断言和量词之前我们谈到的命题都是直观上很容易判断真假的命题，然而，有些命题可能会涉及无穷的数导致要判断真假得检查无穷的情况。比如下面这个命题： 对于每个非负整数 n，$n^2 + n + 41$是质数 实际上，上述的涉及无穷的数的命题在数学上十分常见，以至于有特定的符号来描述，上面的命题也可以写成下面的形式： $$\forall n \in N. n^2 + n + 41 是质数$$ 下面是另一个例子： $$\forall a,b,c,d \in Z^+. a^4 + b^ 4 + c^4 \neq d^4.$$ 这种真假依赖于检查多个变量的命题称为断言。断言常常和一些量词一起出现，比如描述这个断言是针所有情况都为真还是针对某些情况为真。比如，下面这个断言： $$x^2 \geq 0$$ 对任何实数x都为真。而下面这个断言：$$5x^2 - 7 = 0$$则仅当$x = \pm\sqrt{7/5}$才成立 用数学符号来描述某些情况成立的例子如下： $$\exists x \in D \quad P(x)$$ 表示在集合 D 中存在 x，满足 P(x) 证明的模式证明的方法包括： 公理法 穷举法 反证法 数学归纳法]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>证明</tag>
        <tag>命题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git commits 统计分析]]></title>
    <url>%2F2016%2F08%2F27%2Fstatistic-git-commits%2F</url>
    <content type="text"><![CDATA[随着一个项目的推进，项目的代码越来越多，团队成员也可能越来越多。这时候，如何跟踪项目的演进对于项目管理者来说就成了一个问题。项目管理者往往需要知道项目代码数量随着时间的推移发生的变化、每天/每周/每月/每年的提交情况以及每个贡献者的提交情况等等。而这些统计信息无法直接从 git log 中直接获取，最近发现了一个叫GitStats的工具可以从 git 提交历史中自动生成这些统计信息，并生成 HTML 形式的报告。下面简要介绍一下这个工具。 GitStats 生成的统计信息主要有四个方面： 一般统计信息包括以下几项 项目名称 统计的时间段 总共的文件数目 总共的代码行数 总共提交次数、每天平均提交次数 贡献者数量、平均每个贡献者的提交次数 下图是一个例子： 活动信息包括： 过去32周每周的提交次数 按小时统计的提交次数 按星期统计的提交次数 按小时和星期统计的提交次数 按月份统计的提交次数 按年统计的提交次数 按月份和年统计的提交次数 贡献者信息 贡献者列表（包括名字、提交次数以及占总提交次数的百分比，第一次提交日期，最后一次提交日期，加入项目的天数、活跃的天数等等 每位贡献者累积添加的代码行数曲线 每位贡献者的提交次数曲线 每位贡献者每个月的提交次数 每位贡献者每年的提交次数 文件信息包括 总文件数 代码总行数 平均文件大小 文件数量随时间变化曲线 各种类型文件的数量及占的百分比 代码信息 总代码行数 代码行数随时间的变化曲线 总之，自动化地使用 GitStats 生成项目的统计信息能够大大减轻了对多个代码仓库各项指标的跟踪工作，易于管理者统计一段时间来仓库的变化以及每一位贡献者的提交统计。 看了这么多，如果你对 GitStats 感兴趣并想尝试一下，可以 clone 我的代码来批量生成你的所有仓库的统计信息。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git commits</tag>
        <tag>statistic logs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrum 游戏规则]]></title>
    <url>%2F2016%2F08%2F26%2Fscrum-game-rules%2F</url>
    <content type="text"><![CDATA[许多公司都在用 Scrum，我们公司也不例外。那么 Scrum 到底是什么？我们是否真的在实践 Scrum 的原则？要知道如果没有严格按照 Scrum 的原则实践，那么我们用的 Scrum 也就不是 Scrum 了。 Scrum 的定义Scrum 是一个框架，用于开发和持续支持复杂产品的一个过程框架。Scrum 是： 轻量级的 易于理解的 难以精通的（没错！易于理解但难以精通！！！） Scrum 框架由 Scrum 团队以及与之相关的角色、事件、工件和规则组成。框架中的每个部分都有其特定的目的，对于 Scrum 的成功与使用是至关重要的。下文会详细介绍这几个组成部分，在此之前，我们先来看看 Scrum 的理论依据，看看 Scrum 的内部到底流的是什么血液。 Scrum 理论Scrum 实际上是基于经验过程控制理论，也就是经验主义。经验主义主张知识源自实际经验以及从当前已知情况下做出决定所获得。而 Scrum 采用的迭代、增量式的方法正是不断利用实际经验来优化对未来的预测和管理风险。 在经验过程控制中，透明、检视和适应是其中的三大支柱，支撑起每一个经验过程控制的实施。而 Scrum 中也同样流淌着这三种血液。 透明过程中的关键环节必须是透明的。要拥有透明，就要为这些关键环节制定统一的标准，这样所有关心这些环节的人都会有统一的理解。例如在 Scrum 中： 所有参与者谈及过程时都必须使用统一的术语 负责完成工作和验收工作的人必须对“完成”的定义，有一致的理解 检视Scrum 的使用者必须经常检视 Scrum 工件和完成 Sprint 目标的进展，以便发现不必要的差异。检视不应该过于频繁而阻碍工作本身。 适应如果检视者发现过程中的一个或多个方面偏离于可接受范围之外，并且将会导致产品不可接受时，就必须对过程或过程化的内容加以调整。调整工作必须尽快执行才能避免进一步的偏离。 在检视与适应上，Scrum 规定了4个正式事件： Sprint 计划会议 每日 Scrum 站会 Sprint 评审会议 Sprint 回顾会议 以上便是 Scrum 的内在理论，可以看出实际上 Scrum 的核心是要完成透明、检视与适应这三个支柱。Scrum 通过 团队以及与之相关的角色、事件、工件和规则来保证上述这三大支柱成为现实，实际上，在执行 Scrum 游戏规则时，Scrum 团队成员正慢慢有着共同的价值观。 Scrum 价值观承诺、勇气、专注、开放和敬重是决定 Scrum 是否成功的五项价值观。Scrum 团队致力于去实现共同的目标，团队成员有勇气去做正确的事并且处理那些棘手的问题；每个人专注于 Sprint 和 Scrum 团队目标的工作；Scrum 团队及其利益攸关者同意将所有工作和执行工作的挑战进行公开；Scrum 团队成员相互敬重，彼此成为更有能力和独立的人。 了解了 Scrum 的定义、理论依据和价值观，我们现在首先看看 Scrum 中最重要的 Scrum 团队的组成。 Scrum 团队Scrum 团队由一名产品负责人、开发团队和一名 Scrum Master 组成。Scrum 团队有以下特点： 跨职能的自组织团队 自组织团队自己选择如何以最好的方式来完成工作，而不是由团队之外的人来指导 跨职能团队拥有完成工作所需的全部技能，不需要依赖团队之外的人 Scrum 团队之所以这么设计，是为了追求最佳的灵活力、创造力和生产力 产品负责人产品负责人负责最大化产品和开发团队工作的价值，是负责管理产品待办列表的唯一责任人。产品待办列表的管理包括： 清晰地表述产品待办列表项 对产品待办列表项进行排序，使其最好地实现目标和使命 优化开发团队所执行工作的价值 确保产品待办列表对所有人是可见、透明和清晰的，同时显示 Scrum 团队下一步要做的工作 确保开发团队对产品待办列表项有足够深的了解 产品负责人可以亲自完成上述工作，或者也可以让开发团队完成。然而无论何者，产品负责人是最终负责任的人。另外请注意，为了保证产品负责人的工作取得成功，组织中的所有人员都必须尊重他/她的决定；另外一旦待办列表确定，任何人都不得要求开发团队按照另一套需求展开工作或是做其他任何人指定的工作 开发团队开发团队负责创建和交付产品增量。开发团队有以下特点： 他们是自组织的。没有任何人有权告诉开发团队应该如何把产品待办列表变成潜在可发布的功能增量 开发团队是跨职能的，团队作为一个整体，拥有创建产品增量所需的全部技能 在开发团队内部没有头衔，不管承担哪种工作都只有开发人员这一头衔，无一例外。 开发团队内不存在子团队 开发团队中的每个成员也许有特长和专注的领域，但是责任属于整个开发团队 开发团队的规模一般在3至9人，太小没有足够互动，生产力增长不大；太大则需要过多的沟通成本 Scrum MasterScrum Master 负责保证所有人都能正确地理解并实施 Scrum，让 Scrum 团队遵循 Scrum 的理论、实践和规则。 Scrum Master 实际上是一位服务型领导者。通过服务产品负责人、开发人员来最大化 Scrum 团队创造的价值。 Scrum Master 如何服务产品负责人 找到有效管理产品待办列表的办法 帮助 Scrum 团队理解为何需要清晰且简明的产品待办列表项 理解在经验主义环境中的产品规划 确保产品负责人懂得如何来安排产品待办列表使其达到最大化价值 理解并实践敏捷性 按要求或需要引导 Scrum 事件 Scrum Master 如何服务开发团队 在自组织和跨职能方面给予开发团队指导 帮助开发团队创造高价值的产品 移除开发团队工作进展中的障碍 按要求或需要引导 Scrum 事件 在 Scrum 还未完全采纳和理解的组织环境中指导开发团队 Scrum Master 如何服务组织 带领并指导组织采纳 Scrum 在组织范围内规划 Scrum 的实施 帮助员工和利益攸关者理解并实施 Scrum 和经验产品开发 引发能够提升 Scrum 团队生产效率的改变 与其他 Scrum Master 一起工作，增加组织中 Scrum 应用的有效性 至此，Scrum 团队已经介绍完毕，下面来看看 Scrum 中的事件有哪些。 Scrum 事件Scrum 用固定的事件来产生规律性，由此来减少 Scrum 之外的其它会议的必要。Scrum 事件都有时间盒的限定，即每一个事件限制在最长的时间范围内。Scrum 中的每个事件都是用来进行检视和适应的正式机会。下面分别介绍 Scrum 中的几个事件。 SprintSprint 是 Scrum 的核心，其长度（持续时间）为一个月或更短时间。在这段时间内构建一个“完成的”、可用的和潜在可发布的产品增量。在整个开发过程期间，Sprint 的长度通常保持一致。前一个 Sprint 结束后，新的下一个 Sprint 紧接着立即开始。 Sprint 由 Sprint 计划会议、每日 Scrum 站会、开发工作、 Sprint 评审会议和 Sprint 回顾会议构成。 Sprint 计划会议Sprint 中要做的工作在 Sprint 计划会议中来做计划。这份工作计划是由整个 Scrum 团队共同协作完成的。Sprint 计划会议回答以下问题： 接下来的 Sprint 交付的增量中要包含什么内容？ 要如何完成交付增量所需的工作？ 下面详细介绍这两个话题 话题一： 这次 Sprint 能做什么开发团队预测在这次 Sprint 中要开发的功能。产品负责人讲解 Sprint 的目标以及达成该目标所需完成的产品待办列表项。整个 Scrum 团队协同工作来理解 Sprint 的工作。 Sprint 会议的输入是产品待办列表、最新的产品增量、开发团队在这个 Sprint 中能力的预测以及开发团队的以往表现。开发团队自己决定选择产品待办列表项的数量。只有开发团队可以评估接下来的 Sprint 可以完成什么工作。 在开发团队预测完这个 Sprint 中可交付的产品待办列表项之后，Scrum 团队草拟一个Sprint 目标。Sprint 目标是在这个 Sprint 通过实现产品待办列表要达到的目的，同时它也为开发团队提供指引，使得开发团队明确开发增量的目的。 话题二： 如何完成所选的工作？在设定了 Sprint 目标并选出这个 Sprint 要完成的产品待办列表项之后，开发团队将决定如何在 Sprint 中把这些功能构建成“完成”的产品增量。这个 Sprint 中所选出的产品待办列表项加上交付它们的计划称之为 Sprint 待办列表。 开发团队通常从设计整个系统开始，到如何将产品待办列表转换成可工作的产品增量所需要的工作。 在Sprint 计划会议的最后，开发团队规划出在 Sprint 最初几天内所要做的工作，通常以一天或更少为一个单位。开发团队自组织地领取 Sprint 待办产品列表中的工作，领取工作在Sprint 计划会议和 Sprint 期间按需进行。 产品负责人能够帮助解释清楚所选定的产品待办列表项，并作出权衡。如果开发团队认为工作过多或过少，他们可以与产品负责人重新协商所选的产品待办列表项。开发团队也可以邀请其他人员参加会议，以获得技术或领域知识方面的建议。 在 Sprint 计划会议结束时，开发团队应该能够向产品负责人和 Scrum Master 解释他们将如何以自组织团队的形式完成 Sprint 目标并开发出预期的产品增量。 Sprint 目标Sprint 目标是在当前 Sprint 通过实现产品待办列表要达到的目的。它为开发团队提供指引，使得团队明确为什么要构建增量。Sprint 目标在 Sprint 计划会议中确定。Sprint 目标为开发团队在 Sprint 中所实现的功能留有一定的弹性。所选定的产品待办列表项会提供一个连贯一致的功能，也即是 Sprint 目标。Sprint 目标可以是任何其他的连贯性来促使开发团队一起工作而不是分开独自做。 开发团队必须在工作中时刻谨记 Sprint 目标。为了达成 Sprint 目标，需要实现相应的功能和实施所需的技术。如果所需工作和预期的不同，开发团队需要与产品负责人沟通协商 Sprint 待办列表的范围。 每日 Scrum 站会每日 Scrum 站会是一个以 15 分钟为限的事件，它让开发团队同步开发活动，并为接下了的 24 小时制定计划。这需要检视上次每日站会以来的工作和预测下次每日站会之前所能够完成的工作。 每日 Scrum 站会在同一时间同一地点举行，以便降低复杂性。在会议上，每一个开发团队成员都需要说明: 昨天，我为帮助开发团队达成 Sprint 目标做了什么？ 今天，我为帮助开发团队达成 Sprint 目标准备做什么？ 是否有任何障碍在阻碍我或开发团队达成 Sprint 目标？ 开发团队借由每日 Scrum 站会来检视完成 Sprint 目标的进度，并检视完成 Sprint 待办列表的工作进度趋势。每日 Scrum 站会优化了开发团队达成 Sprint 目标的可能性。每天，开发团队应该知道如何以自组织团队来协同工作以达成 Sprint 目标，并在 Sprint 结束时开发出预期中的增量。开发团队或者开发团队成员通常会在每日 Scrum 站会后立即聚到一起进行更详细的讨论，或者为 Sprint 中剩余的工作进行调整或重新计划。 Scrum Master 确保开发团队每日站会如期举行，但开发团队自己负责召开会议。Scrum Master 教导开发团队将每日 Scrum 会议时间控制在 15 分钟内。 Scrum Master 强制执行每日 Scrum 站会规则：只有开发团队成员才能参加。 每日 Scrum 站会增进交流沟通、减少其他会议、发现开发过程中需要移除的障碍、突显并促进快速地做决策、提高开发团队的认知程度。这是一个进行检视与适应的关键会议。 Sprint 评审会议Sprint 评审会议在 Sprint 快结束时举行 ，用以检视所交付的产品增量并按需调整产品待办列表。 在 Sprint 评审会议中，Scrum 团队和利益攸关者协同讨论在这次 Sprint 中所完成的工作。根据完成情况和 Sprint 期间产品待办列表的变化，所有参会人员协同讨论接下来可能要做的事情来优化价值。这是一个非正式会议，并不是一个进度汇报会议，演示增量的目的是为了获取反馈并促进合作。 Sprint 评审会议包含以下内容： 产品负责人邀请 Scrum 团队和主要的利益攸关者参加会议 产品负责人说明哪些产品待办列表项已经“完成”和哪些没有“完成” 开发团队讨论在 Sprint 期间哪些工作做的很好，遭遇到什么问题以及问题是如何解决的 开发团队演示“完成”的工作并解答关于所交付增量的问题 产品负责人讨论当前的产品待办列表的情况。他／她根据到目前为止的进度来预测可能的完成日期（如果有需要的话） 参会的所有人就下一步的工作进行探讨，这样， Sprint 评审会议就能够为接下了的 Sprint 计划会议提供有价值的输入信息 评审市场或潜在的产品使用方式所带来的接下来要做的最有价值的东西的改变 为下个预期产品版本的发布评审时间表、预算、潜力和市场。 Sprint 评审会议的结果是一份修订后的产品待办列表，阐明很可能进入下个 Sprint 的产品待办列表项。产品待办列表也有可能为了迎接新的机会而进行全局性地调整。 Sprint 回顾会议Sprint 回顾会议是 Scrum 团队检视自身并创建下一个 Sprint 改进计划的机会。 Sprint 回顾会议发生在 Sprint 评审会议结束之后，下个 Sprint 计划会议之前。Scrum Master 要确保会议举行，并且每个参会者都明白会议的目的。Scrum Master 教导大家遵守时间盒的规则。Scrum Master 作为 Scrum 过程的责任者，作为团队的一员参加该会议。 Sprint 回顾会议的目的在于： 检视前一个 Sprint 中关于人、关系、过程和工具的情况如何 找出并加以排序做得好的和潜在需要改进的主要方面 制定改进 Scrum 团队工作方式的计划 Scrum Master 鼓励 Scrum 团队在 Scrum 的过程框架内改进开发过程和实践，使得他们能在下个 Sprint 中更高效更愉快。在每个 Sprint 回顾会议中，Scrum 团队通过适当地调整“完成”的定义的方式来计划提高产品质量。 在 Sprint 回顾会议结束时，Scrum 团队应该明确接下来的 Sprint 中需要实施的改进。在下一个 Sprint 中实施这些改进是基于 Scrum 团队对自身的检视而做出的适当调整。虽然改进可以在任何时间执行，Sprint 回顾会议提供了一个专注于检视和适应的正式机会。 Scrum 工件Scrum 的工件以不同的方式表现工作任务和价值，可以用来提供透明以及检视和适应的机会。Scrum 所定义的工件是特别地设计的，是为了给关键信息提供最大透明化，因此每个人对工件都需要有相同的理解。下面是 Scrum 中用到的工件。 产品待办列表产品待办列表是一份有序列表，其中包含产品需要的一切可能的东西，也是产品需求变动的唯一来源。产品负责人负责管理产品待办列表的内容、可用性和排序。 产品待办列表永远是不完整的。最早开发的产品待办列表只列举最初所知的以及理解最透彻的需求。产品待办列表会随着产品及其应用环境的改变而演进。产品待办列表是动态的，需要持续更新以反映出产品需要什么来保持其适用性、竞争力和有用。只要产品存在，产品待办列表也就同样存在。 产品待办列表列出所有的特性、功能、需求、增强和修复等对未来要发布的产品进行的改变。产品待办列表项具有这些属性：描述、次序、估算和价值。 随着产品的使用、价值的获取和获得市场的反馈，产品待办列表会成长为更大和更详尽的列表。因为需求永不停止改变，所以产品待办列表就如一份活的工件。业务需求、市场形势或者技术的变化都会引起产品待办列表的改变。 多个 Scrum 团队常常会一起参与对同一产品的开发。一个产品只有一个产品待办列表用于描述下一步产品开发工作。那么这就可能需要使用能够对产品待办列表项进行分组的属性。 产品待办列表精化指的是为产品待办列表项增添细节、估算和排序的动作。这是一个持续的过程，产品负责人和开发团队协同工作在产品待办列表项的细节上。在产品待办列表精化过程中，产品待办列表项被重新评审和修改。Scrum 团队决定如何来完成精化以及何时来完成。精化的工作通常占用开发团队不超过 10% 的产能。然而，产品负责人或者其他人在产品负责人的斟酌下，产品待办列表项可以在任何时间来更新。 排序越高的产品待办列表项通常比排序低的更清晰同时包含更多细节。根据更清晰的内容和更详尽的细节信息就能做出更为准确的估算；同样，排序越低，则细节信息越少。产品待办列表项中那些即将会占用开发团队下一个 Sprint 大部分时间的项会被加以精化，因此，任一产品待办列表项都能够在 Sprint 的时间盒期限内适当地“完成”。这些能够被开发团队在一个 Sprint 中“完成”的产品待办列表项称为“准备就绪”，它们将作为 Sprint 计划会议中的待选产品列表项。产品待办列表项的足够透明程度通常要经过上述的精化活动来获得。 开发团队负责所有估算工作。产品负责人可以通过帮助开发团队更好地理解需求，并根据情况权衡取舍来影响他们，但是最终估算是由开发团队决定的。 监控目标实现的进度在任何时刻，达成目标的剩余工作是可以累计的。产品负责人至少在每个 Sprint 评审会议中都必须跟踪剩余工作总量。产品负责人比较这次的剩余工作量与之前 Sprint 评审会议时的剩余工作量，来评估在期望的时间点达成目标的进度。这个信息对所有的利益攸关者都是透明的。 各种不同趋势走向的实践已经被使用在预测进度方面，例如，燃尽图（burn-downs）、燃烧图（burn-ups）或者累积流图（cumulative flows）。这些工具都被证实是有用的。然而，它们并不能用来取代经验主义的重要性。在复杂的环境中，未来将要发生的事是无法预知的。只有已经发生的事才能用来做前瞻性的决策。 Sprint 待办列表Sprint 待办列表是一组为当前 Sprint 选出的产品待办列表项，同时加上交付产品增量和实现 Sprint 目标的计划。Sprint 待办列表是开发团队对于下一个产品增量所需的那些功能以及交付那些功能到“完成”的增量中所需工作的预测。 Sprint 产品待办列表将开发团队用来达成 Sprint 目标的所有工作变得清晰可见。 Sprint 产品待办列表是拥有足够细节的计划，任何进度的变化可以在每日 Scrum 站会中清晰地看到。开发团队在 Sprint 期间修改 Sprint 待办列表，使得 Sprint 待办列表在 Sprint 期间涌现。涌现发生在开发团队按计划开展工作并学习到更多的关于哪些工作是达成 Sprint 目标所必需的工作时。 当新工作出现时，开发团队需要将其加入到 Sprint 待办列表中去。随着工作的执行或完成，剩余的工作量被估算并更新。当计划中的某个部分失去开发意义，就可以将其移除。在 Sprint 期间，只有开发团队可以改变 Sprint 待办列表。Sprint 待办列表是高度可见的，是对开发团队计划在当前 Sprint 内工作完成情况的实时反映，该列表由开发团队全权负责。 监控 Sprint 进度在 Sprint 的任何时间点都可以计算 Sprint 待办列表中所有剩余工作的总和。开发团队至少在每日 Scrum 站会时跟踪剩余的工作量，预测达成 Sprint 目标的可能性。通过在 Sprint 中不断跟踪剩余的工作量，开发团队可以管理自己的进度。 增量增量是一个 Sprint 完成的所有产品待办列表项的总和，以及之前所有 Sprint 所产生的增量的价值总和。在 Sprint 的最后，新的增量必须是“完成”的，这意味着它必须可用并且达到了 Scrum 团队“完成”的定义的标准。无论产品负责人是否决定真正发布它，增量必须可用。 工件透明Scrum 依赖于透明。优化价值和控制风险的决定都是基于所获知的工件状态。当工件的状态是完全透明时，这些做出的决定才有一个坚实的基础；当工件的状态是不完全透明时，这些做出的决定就会有瑕疵，而价值也可能因此遭受损失，同时风险也可能会因此而增加。 Scrum Master 必须和产品负责人、开发团队和其他相关人员一起合作，以确保所有工件都是完全透明的。有些实践就是为应对不完全透明的状态而生的，Scrum Master 必须帮助每个人，让他们能够在遇到不透明的情况下采取最合适的实践。Scrum Master 能够通过检视工件、嗅探模式、倾听周围的声音以及观察预期和实际结果的差异来发现不完全透明。 Scrum Master 的职责就是和 Scrum 团队以及组织一起合作增加工件的透明化。这一工作通常包括学习、说服和改变。 透明化不会在一夜之间发生，但是这是一条必经之路。 “完成”的定义当产品待办列表项或增量被描述为“完成”时，每个人都必须理解“完成”意味着什么。虽然在不同 Scrum 团队之间会存在巨大的差别，但是每个团队成员必须对完成工作意味着什么有相同的理解以便确保透明化。这就是 Scrum 团队的“完成”定义，用来评估产品增量是否完成。 这一定义也同时被用来指导开发团队了解在 Sprint 计划会议时能够选择多少产品待办列表项。每个 Sprint 的目标在于交付符合 Scrum 团队当前“完成”的定义的潜在可交付功能增量。 开发团队在每个 Sprint 都交付产品功能增量。这一增量是可用的，所以产品负责人可以选择立即发布它。如果“完成”的定义对增量来说是开发组织的惯例、标准或指南，那么所有 Scrum 团队都必须遵守它，以此为最低标准。如果增量“完成”的定义不是开发组织的惯例，那么 Scrum 团队中的开发团队就必须制定适合于产品的“完成”的定义。如果系统或产品发布由多个 Scrum 团队一起开发，那么所有 Scrum 团队中的开发团队必须一起参与制定“完成”的定义。 每个增量都添加至之前的所有增量上，并且经过彻底地测试，以此确保整合在一起的所有增量都能工作。 随着团队的成熟，“完成”的定义会扩大，包含更为严格的标准来保证更高的质量。任何产品或系统都应该对其上面开发的工作有“完成”的定义。 Scrum 各部分缺一不可Scrum 的角色、工件、事件和规则是不可改变的。虽然只实施部分的 Scrum 是可能的，但这样就不是 Scrum 了。Scrum 只以整体的形式而存在，唯其如此才能作为其他技术、方法和实践的容器运作良好。]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>scrum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实时更新OSM数据库]]></title>
    <url>%2F2016%2F05%2F07%2Fminutely-osm-database%2F</url>
    <content type="text"><![CDATA[巧妇难为无米之炊。对于制图者，地图数据便是一切的基础。OpenStreetMap（简称 OSM ）是一个全球路网数据（不仅仅是路网数据，还包括行政区划、自然要素等数据）的众包平台，所有人都可以免费得到这份全球的数据。由于众包的性质，OSM 的数据每分钟都在发生变化，因此，维护一个实时（分钟级的频率）更新的 OSM 数据源能够使我们的地图有更好的时效性。 依赖的工具 osm2pgsql osm2pgsql 可以将 OSM 的数据导入 PostgreSQL 中，转化成易于渲染的结构，并且支持增量更新。 osmosis osmosis 是一个 java 的命令行工具，主要用来进行 OSM 数据的各种格式之间的转换，这里用来从 OSM 远程服务器中获取更改集，从而 osm2pgsql 可以将此更改集增量应用到数据库中。 PostgreSQL, 带 postgis 拓展 初始化数据库下载全球或者某个区域的 osm 数据，最好选择 pbf 格式，相比于 xml 格式，pbf 格式会小很多。下载的时候记下数据的生产时间，下面选择同步起始时间的时候会用到，这个时间在下载的页面里会有说明。 使用下述 sql 创建一个数据库，并且建立拓展。 createdb osmpsql -d osm -c &apos;CREATE EXTENSION postgis; CREATE EXTENSION hstore;&apos; 这里 osm 是我的数据库名，如果不习惯用命令行，可以用 pgAdmin 来进行上述操作。总之，现在我们有了一个全新的带有空间拓展的数据库了。 使用下面的命令导入之前下载好的数据 osm2pgsql -c -d osm --slim -C &lt;75% Mem&gt; --flat-nodes &lt;flat nodes&gt; -U gis -W -H localhost -P 5432 you.osm.pbf 这里有几个地方要注意，一个是-C选项最好指定你电脑的内存的75%，单位为 Mb，并且最大只能为30000，–flat-nodes 用来指定一个文件路径，存放这个文件的位置至少要有20G的空闲空间（如果导入全球数据的话）。执行这个命令可能会耗费一段时间，特别是导入全球数据，可能需要几天，如果导入全国的数据，我用8G内存的 Macbook Pro 只需要不到一个小时。注意虽然我们下载的数据量可能不是很大，但是导入到数据库后会占据很可观的数据磁盘空间，我的笔记本里全国的数据占据了接近10G的空间，因此导入比较大的范围的数据需要保证有足够的磁盘空间可用。 设定更新频率首先指定更新的工作目录。下面的这行可以放到主目录下的 .bash_profile 里，如果是 windows 用户可以新建一个系统的环境变量。 export WORKDIR_OSM=$HOME/.osmosis 初始化工作目录 mkdir $WORKDIR_OSMosmosis --read-replication-interval-init workingDirectory=$WORKDIR_OSM 上面的命令告诉 osmosis 从哪个目录寻找更新的信息，以及下载数据到哪里。osmosis 会在这个目录里创建 configuration.txt 和 download.lock 这两个文件。download.lock 文件用来确保同一时刻只会进行一个更新任务。configuration.txt 文件则用来指定更新的频率。默认情况下，osmosis 会提取每分钟的更改集，如果想改为提取每小时或者是天的，可以把 configuration.txt 里的 baseurl 中的 replication/minute/ 部分改为 replication/hour/ 或者 replication/day/。默认情况下每次执行更新任务最多只会提取1分钟的更改集，可以把 maxInterval=3600 设为0，这样子就可以一次提取所有的更改集。 为了让osmosis知道从哪个时刻开始进行更新，我们还要告诉它我们刚刚导入的数据的时间，访问Peter Körner’s website tool，输入我们的数据的时间，可以得到一个UTC格式的时间文件，把它保存到工作目录中，并命名为 state.txt。 执行更新任务 osmosis -q --rri --bc --simc --bc --write-xml-change &quot;-&quot; | osm2pgsql -s -a -b &quot;73,3,136,54&quot; -U gis -d osm -P 5432 -H localhost -e 15 -o expire.list - 上述的命令中，如果导入的是全球的数据就不需要有 -b 参数。expire.list 中包含的是第15级的 dirty tile（即数据有更新的瓦片），这些瓦片需要重新生成。 linux 上可以使用 crontab 命令定期执行上述命令，这样就可以得到一个以分钟级的频率与 OSM 数据保持同步的本地数据库了。 如果使用 -b 选项指定了更新的范围，可能会使数据库变大，此时可以使用下面的 sql 删除掉无关的 way 和 relation。 DELETE FROM planet_osm_ways AS w WHERE 0 = (SELECT count(1) FROM planet_osm_nodes AS n WHERE n.id = ANY(w.nodes));DELETE FROM planet_osm_rels AS r WHERE 0=(SELECT count(1) FROM planet_osm_nodes AS n WHERE n.id = ANY(r.parts))AND 0=(SELECT count(1) FROM planet_osm_ways AS w WHERE w.id = ANY(r.parts));REINDEX TABLE planet_osm_ways;REINDEX TABLE planet_osm_rels;VACUUM FULL;]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>OSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的排序算法]]></title>
    <url>%2F2016%2F04%2F22%2Fsorting-algorithms%2F</url>
    <content type="text"><![CDATA[还记得上数据结构的时候，耗费了大量脑细胞却总是记不住种类繁多的排序算法；而勉强记住，应付了考试后，过了几个月又忘得一干二净，没办法，只能写下来供以后参考。 其实从排序算法的类别繁多以及在数据结构课程中占的时间比例可以看出这是计算机领域最经典也是研究最广泛的算法，这样说来，我等凡夫俗子不能马上顿悟也是情有可原了。 闲话少说，进入正题。 排序算法的应用领域在深入算法之前，还是要强调一下排序算法之所以重要，在于它是构成其它算法的基础。比如下面就是应用了排序算法的例子： 搜索： 排过序的数据可以使用二分查找（折半查找）快速地搜索某个元素。 最邻近对： 给定n个数的集合，如何找到相差最小的一对数？如果集合已经排过序，那么一次线性查找就可以完成任务。 元素唯一性 – 给定n个数的集合，里面有重复的元素吗？这是最邻近对问题的一个特例。 频率分布： 给定n个数的集合，哪个数出现的次数最多？（求众数）。如果集合是有序的，相同的元素势必会连在一起，一次线性循环即可搞定。如果要查找任意一个元素k出现了多少次，首先用二分查找找到k，然后再往左移动，直到出现不是k的元素位置，同理也往右移动，这样便可得到k出现的次数。 选择： 一个数列里第k大的元素是哪个？如果元素已经是有序的，那么第k个元素就是我们要找的。 找到两个集合的交集： 如果对两个集合分别排序，两个集合是否相交以及交集是多少就很容易求了。 排序问题的定义首先我们明确一下排序算法要解决的问题，也就是排序问题的定义。算法都有输入和输出，排序问题的输入就是一个包含N条记录的数列，为了下文叙述方便，姑且称为数列A；而输出则是一个排好序的新的数列，这里的排序可以认为是从小到大的一个序列。 OK，让我们看看各种算法是怎样巧妙地把无序的数列变成有序的吧。 基本思路虽然排序算法种类繁多，但是观其内在，都会使用循环不变性这种逻辑方式来解决问题。循环不变性的概念用这样的方式来处理排序问题： 从数列A的第一条记录遍历到最后一条记录，假设数列A有N条记录，那么转换成程序语言也就是从数组0索引循环至N-1索引 在循环的每一步中，都维持一个排好序的数列。这是循环不变性的直接体现。 每一步循环使得未排序的记录减1，排好序的数列中的记录加1。这样等到循环到最后的时候，整个数列就完成了排序。 不同排序算法的差别其实就在于如何遍历原数列以及如何维持排好序的数列。 选择排序选择排序的基本思想是“选择”，即从未排序数列中，每次选出其中最小的元素到已排序的数列中。下面我们就使用循环不变性的概念来组织一下选择排序的基本思路： 输入：包含N条记录的数列A 指针从 0 循环至 N-1 指针为i时，找到剩下记录（也就是指针右侧）中最小的记录 交换指针所处记录和找到的最小记录 在上面的思路中，只有一个数列A，而实际上，数列A的前半部是已排序的数列，而后半部是未排序的数列，中间的分隔则是当前循环的指针i所在位置。由此可见，随着循环不断前进，指针不断前移，已排序的数列越来越长，未排序的数列越来越短，到最后数列A就全部是已排序的了。从这里可以看出，我们只使用数列A的空间就完成了排序，这种只利用输入的数组，不需要额外的空间的称为原地排序。实际应用中，数列A可能惊人的大，因此能够原地排序是一个很好的特性。 下面是C++的实现代码，仅供参考 template&lt;typename T&gt;void selection_sort(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123; // 从第一个记录遍历到最后一个记录 for (int i = lo; i &lt;= hi; ++i) &#123; // 记录当前指针的位置 int min_index = i; // 从剩下的记录中找到最小的一个来 for (int j = i + 1; j &lt;= hi; ++j) &#123; if (a[min_index] &gt; a[j]) &#123; min_index = j; &#125; &#125; // 交换指针所处记录和找到的最小记录 exch(a[i], a[min_index]); &#125;&#125; 选择排序的基本特点 运行时间和输入没有关系，即使输入已经是有序的，也需要二次的时间复杂度 选择排序的记录移动是所有算法中最小的，每一个循环只有一次交换操作，总共只需要N次交换，也即N次移动 插入排序在选择排序中，循环的每一步我们都要线性查找剩余记录中最小的一个记录，而找到记录之后只需一次交换就可以把找到的记录安置到已排序的数列中，即选择记录难，插入记录容易；插入排序的方式正好相反，即插入记录南，选择记录容易。插入排序每次选择的时候就按顺序从剩余记录中取一个，插入的时候得和已排好序的元素比较确定位置。但是由于要插入的是已排序的数列，因此相比于选择排序在无序数列中的选择，插入排序的插入会相对简单一些，特别是数列已经部分排序的时候。 另外插入排序还有一个特性，在插入排序中相同记录在排序前和排序后的相对顺序都是不变的，因为记录要改变位置需要和它左边的记录比较，而如果在排序前记录就大于左边的记录的话是不可能改变位置的。稳定排序通常在涉及到二次排序时比较有用，比如公司的人事数据库先按姓名把员工排好序，然后又按照年龄在之前排好序的基础之上继续排序，这时稳定排序保证年龄相同的员工的排序和第一次按姓名排序的顺序保持一致。 基本思想 输入：包含N条记录的数列A 指针从 0 循环至 N-1 指针为i时，指针所在的记录和位于它左边并且比它大的记录交换 c++参考代码 template&lt;typename T&gt;void insertion_sort(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123; // 从第一个记录遍历到最后一个记录 for (int i = lo; i &lt;= hi; ++i) &#123; // 指针所在的记录和位于它左边并且比它大的记录交换 for (int j = i; j &gt; lo; --j) &#123; if (a[j] &lt; a[j - 1]) &#123; exch(a[j], a[j - 1]); &#125; else &#123; break; &#125; &#125; &#125;&#125; 基本特点 如果输入记录是部分排序的话，插入排序的运行时间是线性的 插入排序是稳定的，选择排序可不是稳定的 shell 排序shell 排序是插入排序的增强版：插入排序在往左比较大小时每次只后退一步，而shell排序每次会后退多步。假设后退h步，那么得到的序列就是一个以h为间隔排序好的序列。shell排序会进行多次h排序。h的取值则从大慢慢减为1，这样做的理由是： 当h很大时，以h为间隔的序列较小，排序可以很快完成 当h变为1时，由于之前已经进行了多次h间隔排序，序列已经部分排序，因此插入排序此时的运行时间是线性的，也可以很快完成。 在实际中，通常h的取值序列有多种，不同的序列会导致不一样的时间复杂度。比较容易计算的是使用 3x + 1 这个公式来产生序列 c++参考代码 template&lt;typename T&gt;void shell_sort(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123; int N = hi - lo + 1; // decide decrease sequence int h = 1; while (h &lt; N / 3) &#123; h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; // h-sort the array for (int i = h + lo; i &lt;= hi; ++i) &#123; for (int j = i; j &gt;= h + lo &amp;&amp; a[j] &lt; a[j - h]; j -= h) &#123; exch(a[j], a[j - h]); &#125; &#125; h = h / 3; &#125;&#125; 基本特点 实现代码少，常用于嵌入式编程 时间复杂度未知，但优于二次 堆排序堆排序体现了好的数据结构对算法的帮助。堆排序和选择排序的原理一致，都是从剩下的记录中不断选择最小的记录出来。但是选择排序需要线性的时间去查找最小记录。而从一个集合中选择最小的记录出来是一个经典的优先队列解决的问题，如果使用堆或者平衡二叉树来实现优先队列的话，就能让这个操作变成$log(N)$时间。从而，借助更好的优先队列实现，堆排序把选择排序从$O(n^2)$复杂度提升到了$O(n*log(n))$ 下面就详细介绍一下堆排序用到的数据结构 堆堆是实现优先队列插入和获取最小值操作的简单而高效的数据结构。堆通过维持记录部分排序而非完全排序来工作，因此会比较高效。一个堆实际上可以用一个二叉树来表示（注意不是二叉搜索树）。在一个最小堆中，一个节点的键值总是比它的子节点要小；在一个最大堆中，一个节点的键值总是比它的子节点要大。 堆使用数组来实现，不需要使用任何的指针。键值在堆中的位置充当了指针的作用。在这个数组中，我们把二叉树的根节点存储在数组的第一个位置（为了方便，数组索引从1开始），相应地把它的左右两个子节点放在第二和第三的位置。一般地，我们可以把完全二叉数第$l$层的$2^l$个键值从左到右放在$2^{l-1}$和$2^l - 1$之间。并且节点之间有以下关系： 位于位置$k$的结点的父结点的位置是 $k / 2$ 位于位置$k$的结点的子节点的位置是 $2k$ 和 $2k + 1$ 如何构造一个堆可以通过往数组末端不断插入记录来递增地构造一个堆。在插入新记录时，堆的顺序可能会不满足预定的条件：在最小堆中新记录可能小于它的父节点，或者是在最大堆中新纪录大于它的父节点。在这种情况下，需要交换这个记录和它的父节点的位置，这称作一次上游,对这个记录不断上浮直到不能继续上游为止，就维持了堆的既有顺序。下面的代码显示了最小堆的上游代码： void swim(int k) &#123; // parent of node at k is k/2 while (k &gt; 1 &amp;&amp; pq_[k / 2] &gt; pq_[k]) &#123; // if children's node is larger than parent, exchange exch(pq_[k], pq_[k / 2]); // swim up a level k /= 2; &#125;&#125; 对于一个有$n$个记录的堆来说，一次上浮最多只需要$lg(n)$次操作，因此，构造堆的时间复杂度为$O(n*log(n))$复杂度 如何从堆中取得最小值从最小堆中取得最小的记录只需取数组的第一个元素即可，但是取完后二叉树会出现一个洞，需要把数组最后的一个记录填补到已经移除的第一个记录上；把最后一个记录移上来后可能会破坏堆的性质，如最小堆中根结点的记录可能会大于子结点，如果出现这种情况，需要将根结点和其较大的子结点交换，这称为一次下沉。下面是最小堆的下沉代码： void sink(int k) &#123; // make sure k is not the bottom level while (2 * k &lt;= N_) &#123; // j is the left children int j = 2 * k; if (j &lt; N_ &amp;&amp; pq_[j] &lt; pq_[j + 1]) &#123; // now, j is the bigger children j++; &#125; if (pq_[k] &gt; pq_[j]) &#123; break; &#125; // if parent node is smaller than the bigger children, exchange exch(pq_[k], pq_[j]); // sink down a level k = j; &#125;&#125; 对于一个有$n$个记录的堆来说，一次下沉最多只需要$lg(n)$次操作，因此，取得最小值的操作的时间复杂度为$O(log(n))$ 更快的构建堆的方法一条一条地插入记录来构造堆的方法需要$O(n*log(n))$的时间复杂度，如果记录序列全部已知，我们可以采用一种自底向上的构造方法，基本思路是从底端不是叶子结点的记录开始，做下沉操作，这样只需处理$n/2$个结点，这个时间复杂度基本上是线性的。下面是最大堆的下沉操作和构造方式： template&lt;typename T&gt; void sink(std::vector&lt;T&gt;&amp; a, int k, int N) &#123; // NOTE: the value of node k is a[k - 1] // make sure k is not the bottom level while (2 * k &lt; N) &#123; // j is the left children int j = 2 * k; if (j &lt; N &amp;&amp; a[j - 1] &lt; a[j]) &#123; // now, j is the bigger children j++; &#125; if (a[k - 1] &gt; a[j - 1]) &#123; break; &#125; // if parent node is smaller than the bigger children, exchange exch(a[k - 1], a[j - 1]); // sink down a level k = j; &#125; &#125; // Heap construction for (int k = N / 2; k &gt;= 1; --k) &#123; // loop for every non leaf node sink(pq, k, N); &#125; 堆排序实现参考代码(这里用到了上面的最大堆的下沉方法) template&lt;typename T&gt;void heap_sort(std::vector&lt;T&gt;&amp; pq) &#123; int N = pq.size(); // Heap construction for (int k = N / 2; k &gt;= 1; --k) &#123; // loop for every non leaf node sink(pq, k, N); &#125; // Sort down while(N &gt; 1) &#123; exch(pq[0], pq[N - 1]); sink(pq, 1, --N); &#125;&#125; 基本特点 最坏的情况下也能达到$O(n*log(n))$，这是排序算法的理论最优。 缺点在于内部循环较长，无法使用缓存，并且是不稳定的，在实际中并不是最快的 归并排序归并排序体现了分治的策略。主要思想是把大问题分解成小问题，不断递归去求解。下面的算法把数列递归地进行分解，然后再合并。 代码实现 // merge tow subarraytemplate&lt;typename T&gt;void merge(std::vector&lt;T&gt;&amp; a, std::vector&lt;T&gt;&amp; aux, int lo, int mid, int hi) &#123; for (int i = lo; i &lt;= hi; ++i) &#123; aux[i] = a[i]; &#125; int m = lo; int n = mid + 1; for (int i = lo; i &lt;= hi; ++i) &#123; if (m &gt; mid) &#123; a[i] = aux[n++]; &#125; else if (n &gt; hi) &#123; a[i] = aux[m++]; &#125; else if (aux[n] &lt; aux[m]) &#123; a[i] = aux[n++]; &#125; else &#123; a[i] = aux[m++]; &#125; &#125;&#125;// resuive sortconst int CUTOFF = 7;template&lt;typename T&gt;void merge_sort(std::vector&lt;T&gt;&amp; a, std::vector&lt;T&gt;&amp; aux, int lo, int hi) &#123; if (hi &lt;= lo) &#123; return; &#125; // use insertion sort for small subarrays if (hi &lt;= lo + CUTOFF - 1) &#123; insertion_sort(a, lo, hi); return; &#125; int mid = lo + (hi - lo) / 2; merge_sort(a, aux, lo, mid); merge_sort(a, aux, mid + 1, hi); // do not merge if already sorted if (a[mid] &lt; a[mid + 1]) &#123; return; &#125; merge(a, aux, lo, mid, hi);&#125; 上述实现中借助了一个额外的aux数组来存储记录，并且在子问题规模很小时采用了插入排序。 基本特点 归并排序的平均时间复杂度为$O(n*log(n))$ 归并排序不是原地排序，需要额外的存储空间 归并排序的非递归实现基本思想 遍历数组，首先归并排序大小为1的子数组 继续遍历，不断归并大小为2，4，16的子数组 template&lt;typename T&gt;void bottom_up_merge_sort(std::vector&lt;T&gt;&amp; a, std::vector&lt;T&gt;&amp; aux, int lo, int hi) &#123; int N = hi - lo + 1; for (int sz = 1; sz &lt; N; sz += sz) &#123; for (int k = lo; k &lt; lo + N - sz; k += (sz + sz)) &#123; merge(a, aux, k, k + sz - 1, std::min(k + sz + sz - 1, N - 1)); &#125; &#125;&#125; 基本特点 如果有足够的空间的话，非递归的归并排序的稳定性是工业级别的 快速排序快速排序和归并排序类似，都是递归的算法，通过把问题分解为子问题来解决。不同的是，归并排序每次都把问题分成相同大小的两个子问题，然后通过归并操作进行合并；而快速排序则通过拆分的方式来分解问题，即每次找一个中间元素，把记录分成小于该中间元素（在中间元素左边）和大于该中间元素（在中间元素右边）的这两部分，此时中间元素已经排好序，只需对左右两边递归继续采用相同方式拆分即可。 和归并排序的归并操作是线性的时间复杂度类似，快速排序的拆分操作也是线性的。归并排序和快速排序的递归分解都把问题变成了一个二叉树的结构，而归并排序的二叉树是完全二叉树，因此树高是$lg(n)$，而快速排序的树高则与中间元素的选取有很大的关系，为了达到了归并排序相似的树高，要求输入记录必须是无序的，研究表明，无序的二叉树插入的树高平均只比完全二叉树高36%，因此该种情况下的快速排序和归并排序的时间复杂度是相同的。当然由于快速排序加入了随机的因素，我们只能说平均情况下快速排序和归并排序的时间复杂度是相同的，也不排除很小的概率的情况下快速排序的时间复杂度为$n^2$ 基本思想 随机打乱原始记录 针对索引为j的记录进行拆分，使得： 记录a[j]位于最终已排序的位置 j左边的记录没有比a[j]大的 j右边的记录没有比a[j]小的 对拆分后的各个部分递归进行上述处理 代码实现 template&lt;typename T&gt;int partition(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123; int i = lo; int j = hi + 1; while(true) &#123; // process i pointer // find item on left to swap while(a[++i] &lt; a[lo]) &#123; if (i == hi) &#123; break; &#125; &#125; // process j pointer // find item on right to swap while(a[--j] &gt; a[lo]) &#123; if (j == lo) &#123; break; &#125; &#125; // find if pointers cross if (i &gt;= j) &#123; break; &#125; // swap exch(a[i], a[j]); &#125; // swap with partition item exch(a[lo], a[j]); // return index of item now known to be in place return j;&#125;template&lt;typename T&gt;void quick_sort_sub(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123; if (hi &lt;= lo + CUTOFF) &#123; // improvement 1: use insertion fort for small subarray insertion_sort(a, lo, hi); return; &#125; // improvement 2: estimate partition item with median of three samples int m = median_of_three(a, lo, lo + (hi - lo)/ 2, hi); exch(a[lo], a[m]); int j = partition(a, lo, hi); quick_sort_sub(a, lo, j - 1); quick_sort_sub(a, j + 1, hi);&#125;template&lt;typename T&gt;void quick_sort(std::vector&lt;T&gt;&amp; a) &#123; // shuffle is needed for performance guarantee shuffle(a); quick_sort_sub&lt;T&gt;(a, 0, static_cast&lt;int&gt;(a.size()) - 1);&#125; 上面的代码使用了两个提升：和归并排序中一样，我们在记录序列很小时采用了插入排序；另外我们本来是采用随机打乱后的记录顺序来选取中间值，为了让得到的二叉树更加平衡，我们需要选择接近数列中位数的记录作为中间值，这里我们采用了抽样的方式来计算中值。 基本特点 虽然快速排序理论上只能在概率上趋近于$n*lg(n)$的时间复杂度，但是由于它的内层循环较小，并且容易利用计算机缓存等原因，一个设计得很好的快速排序的效率是归并排序和堆排序的2-3倍！ 在实际应用中，如果记录有许多重复的话，会发现快速排序接近于$n^2$的时间复杂度，这时候我们需要使用快速排序的改进版：3路快速排序 3路快速排序基本思想是： 把记录序列查分成3部分（而不是之前的两部分） 在lt和gt中间的记录都等于中间元素 lt左边的记录都不大于中间元素 lt右边的记录都不小于中间元素 实现代码 // * Let v be partitioning item a[lo].// * Scan i from left to right.// - (a[i] &lt; v): exchange a[lt] with a[i]; increment both lt and i// - (a[i] &gt; v): exchange a[gt] with a[i]; decrement gt;// - (a[i] == v): increment itemplate&lt;typename T&gt;void quick_sort_3way_sub(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123; if (hi &lt;= lo + CUTOFF) &#123; // improvement 1: use insertion fort for small subarray insertion_sort(a, lo, hi); return; &#125; int lt = lo; int i = lo; int gt = hi; // improvement 2: estimate partition item with median of three samples int m = median_of_three(a, lo, lo + (hi - lo)/ 2, hi); exch(a[lo], a[m]); // partition item T v = a[lo]; while(i &lt;= gt) &#123; if (a[i] &lt; v) &#123; exch(a[lt++], a[i++]); &#125; else if (a[i] &gt; v) &#123; exch(a[i], a[gt--]); &#125; else &#123; i++; &#125; &#125; quick_sort_3way_sub(a, lo, lt - 1); quick_sort_3way_sub(a, gt + 1, hi);&#125;template&lt;typename T&gt;void quick_sort_3way(std::vector&lt;T&gt;&amp; a) &#123; // shuffle is needed for performance guarantee shuffle(a); quick_sort_3way_sub&lt;T&gt;(a, 0, static_cast&lt;int&gt;(a.size()) - 1);&#125; 至此，经典的排序方法已经介绍完毕。除了选择排序和插入排序需要二次的时间复杂度外，堆排序、归并排序以及快速排序都能达到$n*lg(n)$的时间复杂度，而这也是证明了的排序算法时间复杂度的下界，即这已经是最优算法了。但是从之前的讨论可以看到，在实际情况中，受到各种因素的限制，时间复杂度相同的算法的实际效率并不同，并且有可能相差数倍，当然，这是大O方式来衡量时间复杂度的一个弊端：即它只能忽略影响算法效率的其它因素，单单从输入规模上来看算法运行时间随输入规模的变化。从这个角度来看，虽然堆排序、归并排序以及快速排序都是最优算法，但是还可能有更快的排序算法等待着我们去发掘。 几种排序方法的比较最后再整体比较一下上述的几类排序算法，算是一个总结： 排序方法 原地排序 稳定排序 最差 平均 最好 备注 选择排序 是 否 $$N^2/2$$ $$N^2/2$$ $$N^2/2$$ 只需要N次交换 插入排序 是 是 $$N^2/2$$ $$N^2/4$$ $$N$$ N很小或数据部分排序时适用 shell排序 是 否 未知 未知 $$N$$ 实现代码少常用于嵌入式编程，时间复杂度未知但低于二次 快速排序 是 否 $$N^2/2$$ $$2N*lg(N)$$ $$lg(N)$$ 实际使用中最快的算法 3路快速排序 是 否 $$N^2/2$$ $$2N*lg(N)$$ $$N$$ 快速排序在大量重复记录下的改进 归并排序 否 是 $$N*lg(N)$$ $$N*lg(N)$$ $$N*lg(N)$$ 稳定排序 堆排序 是 否 $$2N*lg(N)$$ $$2N*lg(N)$$ $$N*lg(N)$$ 原地排序的（节省空间） ？？？ 是 是 $$N*lg(N)$$ $$N*lg(N)$$ $$N*lg(N)$$ 终极排序算法:)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
