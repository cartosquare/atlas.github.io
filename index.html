<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>徐翔的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="徐翔的博客">
<meta property="og:url" content="http://cartosquare.github.io/index.html">
<meta property="og:site_name" content="徐翔的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="徐翔的博客">
  
    <link rel="alternate" href="/atom.xml" title="徐翔的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">徐翔的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">漂亮做事 清楚行文</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://cartosquare.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2016-05-07-minutely-osm-database" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/07/2016-05-07-minutely-osm-database/" class="article-date">
  <time datetime="2016-05-06T16:00:00.000Z" itemprop="datePublished">2016-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/07/2016-05-07-minutely-osm-database/">实时更新OSM数据库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>巧妇难为无米之炊。对于制图者，地图数据便是一切的基础。<a href="http://www.openstreetmap.org/" target="_blank" rel="external">OpenStreetMap</a>（简称OSM）是一个全球路网数据（不仅仅是路网数据，还包括行政区划、自然要素等数据）的众包平台，地球上的每个人都可以免费得到这份全球的数据。由于众包的性质，OSM的数据每分钟都在发生变化，因此，维护一个实时（分钟级的频率）更新的OSM数据源使我们的地图能够有更好的时效性。</p>
<h2 id="依赖的工具"><a href="#依赖的工具" class="headerlink" title="依赖的工具"></a>依赖的工具</h2><ul>
<li><a href="https://github.com/openstreetmap/osm2pgsql" target="_blank" rel="external">osm2pgsql</a></li>
</ul>
<p>osm2pgsql 可以将OSM的数据导入PostgreSQL中，转化成易于渲染的结构，并且支持增量更新。</p>
<ul>
<li><a href="https://github.com/openstreetmap/osmosis" target="_blank" rel="external">osmosis</a></li>
</ul>
<p>osmosis 是一个java的命令行工具，主要用来进行OSM数据的各种格式之间的转换，这里用来从OSM远程服务器中获取更改集，从而osm2pgsql可以将此更改集增量应用到数据库中。</p>
<ul>
<li>PostgreSQL, 带postgis拓展</li>
</ul>
<p>在进行下面的操作之前，请先安装好这三个软件。</p>
<h2 id="一、-初始化数据库"><a href="#一、-初始化数据库" class="headerlink" title="一、 初始化数据库"></a>一、 初始化数据库</h2><ol>
<li><p>下载<a href="http://planet.openstreetmap.org/" target="_blank" rel="external">全球</a>或者<a href="http://download.geofabrik.de/index.html" target="_blank" rel="external">某个区域</a>的osm数据，最好选择pbf格式，相比于xml格式，pbf格式会小很多。下载的时候记下数据的生产时间，下面选择同步起始时间的时候会用到，这个时间在下载的页面里会有说明。</p>
</li>
<li><p>使用下述sql创建一个数据库，并且建立拓展。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">createdb osm</div><div class="line">psql -d osm -c &apos;CREATE EXTENSION postgis; CREATE EXTENSION hstore;&apos;</div></pre></td></tr></table></figure>
<p>这里osm是我的数据库名，如果不习惯用命令行，可以用pgAdmin来进行上述操作。总之，现在我们有了一个全新的带有空间拓展的数据库了。</p>
<ol>
<li>使用下面的命令导入之前下载好的数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">osm2pgsql -c -d osm --slim -C &lt;75% Mem&gt; --flat-nodes &lt;flat nodes&gt; -U gis -W -H localhost -P 5432 you.osm.pbf</div></pre></td></tr></table></figure>
<p>这里有几个地方要注意，一个是-C选项最好指定你电脑的内存的75%，单位为Mb，并且最大只能为30000，–flat-nodes 用来指定一个文件路径，存放这个文件的位置至少要有20G的空闲空间（如果导入全球数据的话）。<br>执行这个命令可能会耗费一段时间，特别是导入全球数据，可能需要几天，如果导入全国的数据，我用8G内存的Macbook Pro只需要不到一个小时。注意虽然我们下载的数据量可能不是很大，但是导入到数据库后会占据很可观的数据磁盘空间，我的笔记本里全国的数据占据了接近10G的空间，因此导入比较大的范围的数据需要保证有足够的磁盘空间可用。</p>
<h2 id="二、初始化更新频率"><a href="#二、初始化更新频率" class="headerlink" title="二、初始化更新频率"></a>二、初始化更新频率</h2><ol>
<li>首先指定更新的工作目录。下面的这行可以放到主目录下的 .bash_profile里，如果是windows用户可以新建一个系统的环境变量。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export WORKDIR_OSM=$HOME/.osmosis</div></pre></td></tr></table></figure>
<ol>
<li>初始化工作目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir $WORKDIR_OSM</div><div class="line">osmosis --read-replication-interval-init workingDirectory=$WORKDIR_OSM</div></pre></td></tr></table></figure>
<p>上面的命令告诉osmosis从哪个目录寻找更新的信息，以及下载数据到哪里。osmosis会在这个目录里创建configuration.txt和download.lock这两个文件。download.lock文件用来确保同一时刻只会进行一个更新任务。configuration.txt文件则用来指定更新的频率。默认情况下，osmosis会提取每分钟的更改集，如果想改为提取每小时或者是天的，可以把configuration.txt里的baseurl中的replication/minute/部分改为replication/hour/或者replication/day/。默认情况下每次执行更新任务最多只会提取1分钟的更改集，可以把maxInterval=3600设为0，这样子就可以一次提取所有的更改集。</p>
<p>为了让osmosis知道从哪个时刻开始进行更新，我们还要告诉它我们刚刚导入的数据的时间，访问<a href="https://osm.mazdermind.de/replicate-sequences/" target="_blank" rel="external">Peter Körner’s website tool</a>，输入我们的数据的时间，可以得到一个UTC格式的时间文件，把它保存到工作目录中，并命名为state.txt。</p>
<ol>
<li>执行更新任务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">osmosis -q --rri --bc --simc --bc --write-xml-change &quot;-&quot; | osm2pgsql -s -a -b &quot;73,3,136,54&quot; -U gis -d osm -P 5432 -H localhost -e 15 -o expire.list -</div></pre></td></tr></table></figure>
<p>上述的命令中，如果导入的是全球的数据就不需要有-b参数。expire.list中包含的是底第15级的dirty tile（即数据有更新的瓦片），这些瓦片需要重新生成。</p>
<p>linux上可以使用crontab命令定期执行上述命令，这样就可以得到一个以分钟级的频率与OSM数据保持同步的本地数据库了。</p>
<p>如果使用-b选项指定了更新的范围，可能会使数据库变大，此时可以使用下面的sql删除掉无关的way和relation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DELETE FROM planet_osm_ways AS w WHERE 0 = (SELECT count(1) FROM planet_osm_nodes AS n WHERE n.id = ANY(w.nodes));</div><div class="line"></div><div class="line">DELETE FROM planet_osm_rels AS r WHERE</div><div class="line">  0=(SELECT count(1) FROM planet_osm_nodes AS n WHERE n.id = ANY(r.parts))</div><div class="line">AND</div><div class="line">  0=(SELECT count(1) FROM planet_osm_ways AS w WHERE w.id = ANY(r.parts));</div><div class="line">REINDEX TABLE planet_osm_ways;</div><div class="line">REINDEX TABLE planet_osm_rels;</div><div class="line">VACUUM FULL;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cartosquare.github.io/2016/05/07/2016-05-07-minutely-osm-database/" data-id="cis0h2tb300011djgmw8f6qpn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016-04-22-sorting-algorithms" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/22/2016-04-22-sorting-algorithms/" class="article-date">
  <time datetime="2016-04-21T16:00:00.000Z" itemprop="datePublished">2016-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/22/2016-04-22-sorting-algorithms/">排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>排序算法是计算机领域最经典也是研究最广泛的算法，并且是许多算法的基础。</p>
<h2 id="排序算法的应用领域"><a href="#排序算法的应用领域" class="headerlink" title="排序算法的应用领域"></a>排序算法的应用领域</h2><ul>
<li><strong>搜索</strong>： 排过序的数据可以使用二分查找（折半查找）快速地搜索某个元素。</li>
<li><strong>最邻近对</strong>： 给定n个数的集合，如何找到相差最小的一对数？如果集合已经排过序，那么一次线性查找就可以完成任务。</li>
<li><strong>元素唯一性</strong> – 给定n个数的集合，里面有重复的元素吗？这是最邻近对问题的一个特例。</li>
<li><strong>频率分布</strong>： 给定n个数的集合，哪个数出现的次数最多？（求众数）。如果集合是有序的，相同的元素势必会连在一起，一次线性循环即可搞定。如果要查找任意一个元素k出现了多少次，首先用二分查找找到k，然后再往左移动，直到出现不是k的元素位置，同理也往右移动，这样便可得到k出现的次数。</li>
<li><strong>选择</strong>： 一个数列里第k大的元素是哪个？如果元素已经是有序的，那么第k个元素就是我们要找的。</li>
<li><strong>凸包</strong>： 给定二维平面上的n个点，求最小的能包含所有点的多边形？如果点根据x坐标进行排序，就可以按顺序把点插入（详细算法以后会专门介绍）。</li>
<li><strong>找到两个集合的交集</strong>： 如果对两个集合分别排序，两个集合是否相交以及交集是多少就很容易求了。</li>
</ul>
<h2 id="排序的语义"><a href="#排序的语义" class="headerlink" title="排序的语义"></a>排序的语义</h2><p>排序有几个重要的语义，分述如下：</p>
<ul>
<li>递增还是递减顺序？</li>
<li>使用某个键值排序还是用整个记录去排序？</li>
</ul>
<p>上述两个歧义可以通过让客户端自己指定比较函数来解决。</p>
<ul>
<li>遇到相同的元素怎么办？有时候即使多个记录的某个键值相同，但是这些记录间的相互顺序有可能是重要的，因为之前它们可能根据其它键值排过序。如果一个排序算法能够保持相同元素的相对顺序不变，那么称这个算法是稳定的。可惜的是比较快的算法几乎都不是稳定的。另外需要注意如果相同的元素特别多，一些系统默认的比较快的排序算法有可能会很慢！</li>
<li>遇到非数值型的数据怎么办？比如在排序一个整形数列时遇到string类型，排序一个string类型时遇到Beijing 和PeKing 或者是 北京师范大学和北师大？它们的相互顺序应该怎么确定？</li>
</ul>
<h2 id="几种排序方法的比较"><a href="#几种排序方法的比较" class="headerlink" title="几种排序方法的比较"></a>几种排序方法的比较</h2><table>
<thead>
<tr>
<th>排序方法</th>
<th>原地排序</th>
<th>稳定排序</th>
<th>最差</th>
<th>平均</th>
<th>最好</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>是</td>
<td>否</td>
<td>$$\begin{align} N^2/2 \end{align}$$</td>
<td>$$\begin{align} N^2/2 \end{align}$$</td>
<td>$$\begin{align} N^2/2 \end{align}$$</td>
<td>只需要N次交换   </td>
</tr>
<tr>
<td>插入排序</td>
<td>是</td>
<td>是</td>
<td>$$\begin{align} N^2/2 \end{align}$$</td>
<td>$$\begin{align} N^2/4 \end{align}$$</td>
<td>$$\begin{align}N \end{align}$$</td>
<td>通常在N很小或是数据以及部分排序的时候使用</td>
</tr>
<tr>
<td>shell排序</td>
<td>是</td>
<td>否</td>
<td>未知</td>
<td>未知</td>
<td>$$\begin{align}N\end{align}$$</td>
<td>实现代码很少，通常用于嵌入式编程，时间复杂度未知但低于二次</td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td>是</td>
<td>否</td>
<td>$$\begin{align} N^2/2 \end{align}$$</td>
<td>$$\begin{align} 2N\lg(N) \end{align}$$</td>
<td>$$\begin{align}lg(N) \end{align}$$</td>
<td>概率上保证 $$\begin{align} 2N\lg(N) \end{align}$$的时间复杂度，实际使用中最快的算法</td>
</tr>
<tr>
<td>3路快速排序</td>
<td>是</td>
<td>否</td>
<td>$$\begin{align} N^2/2 \end{align}$$</td>
<td>$$\begin{align} 2N\lg(N) \end{align}$$</td>
<td>$$\begin{align}N \end{align}$$</td>
<td>提升快速排序在大量重复记录情况下的效率</td>
</tr>
<tr>
<td>归并排序</td>
<td>否</td>
<td>是</td>
<td>$$\begin{align} N\lg(N) \end{align}$$</td>
<td>$$\begin{align} N\lg(N) \end{align}$$</td>
<td>$$\begin{align} N\lg(N) \end{align}$$</td>
<td>严格保证了$$\begin{align} N\lg(N) \end{align}$$的时间复杂度，并且是稳定的</td>
</tr>
<tr>
<td>堆排序</td>
<td>是</td>
<td>否</td>
<td>$$\begin{align} 2N\lg(N) \end{align}$$</td>
<td>$$\begin{align} 2N\lg(N) \end{align}$$</td>
<td>$$\begin{align} N\lg(N) \end{align}$$</td>
<td>严格保证了$$\begin{align} N\lg(N) \end{align}$$的时间复杂度，并且原地排序的（节省空间）</td>
</tr>
<tr>
<td>？？？</td>
<td>是</td>
<td>是</td>
<td>$$\begin{align} N\lg(N) \end{align}$$</td>
<td>$$\begin{align} N\lg(N) \end{align}$$</td>
<td>$$\begin{align} N\lg(N) \end{align}$$</td>
<td>终极排序算法:)</td>
</tr>
</tbody>
</table>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>基本思想</p>
<ol>
<li>输入：包含N条记录的数列A</li>
<li>从0 循环至 N-1</li>
<li>在第i次循环中，找到剩下记录中最小纪录的索引值 min</li>
<li>交换 A[i] 和 A[min]</li>
</ol>
<p>实现代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; ++i) &#123;</div><div class="line">        <span class="keyword">int</span> min_index = i;</div><div class="line">            </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= hi; ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (a[min_index] &gt; a[j]) &#123;</div><div class="line">                min_index = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        <span class="comment">// swap a[i] and a[min_index]</span></div><div class="line">        exch(a[i], a[min_index]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>选择排序的基本特点</p>
<ul>
<li>运行时间和输入没有关系，即使输入已经是有序的，也需要二次的时间复杂度</li>
<li>选择排序的记录移动是所有算法中最小的，只有线性时间的交换</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>基本思想</p>
<ol>
<li>输入：包含N条记录的数列A</li>
<li>从0 循环至 N-1</li>
<li>在第i次循环中，把A[i]和位于它左边并且比它大的记录交换</li>
</ol>
<p>实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void insertion_sort(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123;</div><div class="line">    for (int i = lo; i &lt;= hi; ++i) &#123;</div><div class="line">        for (int j = i; j &gt; lo; --j) &#123;</div><div class="line">            if (a[j] &lt; a[j - 1]) &#123;</div><div class="line">                exch(a[j], a[j - 1]);</div><div class="line">            &#125; else &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本特点</p>
<ul>
<li>如果输入记录是部分排序的话，插入排序的运行时间是线性的</li>
</ul>
<h2 id="shell-排序"><a href="#shell-排序" class="headerlink" title="shell 排序"></a>shell 排序</h2><p>shell 排序是插入排序的增强版：插入排序在往左比较大小时每次只后退一步，而shell排序每次会后退多步。假设后退h步，那么得到的序列就是一个以h为间隔排序好的序列。shell排序会进行多次h排序。h的取值则从大慢慢减为1，这样做的理由是：</p>
<ul>
<li>当h很大时，以h为间隔的序列较小，排序可以很快完成</li>
<li>当h变为1时，由于之前已经进行了多次h间隔排序，序列已经部分排序，因此插入排序此时的运行时间是线性的，也可以很快完成。</li>
</ul>
<p>在实际中，通常h的取值序列有多种，不同的序列会导致不一样的时间复杂度。比较容易计算的是使用 3x + 1 这个公式来产生序列</p>
<p>实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void shell_sort(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123;</div><div class="line">    int N = hi - lo + 1;</div><div class="line">    </div><div class="line">    // decide decrease sequence</div><div class="line">    int h = 1;</div><div class="line">    while (h &lt; N / 3) &#123;</div><div class="line">        h = 3 * h + 1;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    while (h &gt;= 1) &#123;</div><div class="line">        // h-sort the array</div><div class="line">        for (int i = h + lo; i &lt;= hi; ++i) &#123;</div><div class="line">            for (int j = i; j &gt;= h + lo &amp;&amp; a[j] &lt; a[j - h]; j -= h) &#123;</div><div class="line">                exch(a[j], a[j - h]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        h = h / 3;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序体现了好的数据结构对算法的帮助。堆排序和选择排序的原理一致，都是从剩下的记录中不断选择最小的记录出来。但是选择排序需要线性的时间去查找最小记录。而从一个集合中选择最小的记录出来是一个经典的优先队列解决的问题，如果使用堆或者平衡二叉树来实现优先队列的话，就能让这个操作变成log(N)时间。从而，借助更好的优先队列实现，堆排序把选择排序从$$\begin{align}O(n^2)\end{align}$$复杂度提升到了$$\begin{align}O(n\log(n))\end{align}$$</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是实现优先队列插入和获取最小值操作的简单而高效的数据结构。他通过维持记录部分排序而非完全排序来工作，因此会比较高效。一个堆实际上可以用一个二叉树来表示（注意不是二叉搜索树！）。在一个最小堆中，一个节点的键值总是比它的子节点要小；在一个最大堆中，一个节点的键值总是比它的子节点要大。</p>
<p>堆使用数组来实现，不需要使用任何的指针！键值在堆中的位置充当了指针的作用。在这个数组中，我们把二叉树的根节点存储在数组的第一个位置（为了方便，数组索引从1开始），相应地把它的左右两个子节点放在第二和第三的位置。一般地，我们可以把完全二叉数第l层的$$\begin{align}2^l\end{align}$$个键值从左到右放在$$\begin{align}2^{l-1}\end{align}$$和$$\begin{align}2^l - 1\end{align}$$之间。并且节点之间有以下关系：</p>
<ul>
<li>位于位置k的结点的父结点的位置是 k / 2</li>
<li>位于位置k的结点的子节点的位置是 2k 和 2k + 1</li>
</ul>
<h2 id="如何构造一个堆"><a href="#如何构造一个堆" class="headerlink" title="如何构造一个堆"></a>如何构造一个堆</h2><p>可以通过往数组末端不断插入记录来递增地构造一个堆。在插入新记录时，堆的顺序可能会不满足预定的条件：在最小堆中新记录可能小于它的父节点，或者是在最大堆中新纪录大于它的父节点。在这种情况下，需要交换这个记录和它的父节点的位置，这称作一次上游,对这个记录不断上浮直到不能继续上游为止，就维持了堆的既有顺序。下面的代码显示了最小堆的上游代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void swim(int k) &#123;</div><div class="line">    // parent of node at k is k/2</div><div class="line">    while (k &gt; 1 &amp;&amp; pq_[k / 2] &gt; pq_[k]) &#123;</div><div class="line">        // if children&apos;s node is larger than parent, exchange</div><div class="line">        exch(pq_[k], pq_[k / 2]);</div><div class="line">        </div><div class="line">        // swim up a level</div><div class="line">        k /= 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于一个有n个记录的堆来说，一次上浮最多只需要$$\begin{align}\lg(n)\end{align}$$次操作，因此，构造堆的时间复杂度为$$\begin{align}O(n\log(n))\end{align}$$复杂度</p>
<h2 id="如何从堆中取得最小值"><a href="#如何从堆中取得最小值" class="headerlink" title="如何从堆中取得最小值"></a>如何从堆中取得最小值</h2><p>从最小堆中取得最小的记录只需取数组的第一个元素即可，但是取完后二叉树会出现一个洞，需要把数组最后的一个记录填补到已经移除的第一个记录上；把最后一个记录移上来后可能会破坏堆的性质，如最小堆中根结点的记录可能会大于子结点，如果出现这种情况，需要将根结点和其较大的子结点交换，这称为一次下沉。下面是最小堆的下沉代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void sink(int k) &#123;</div><div class="line">    // make sure k is not the bottom level</div><div class="line">    while (2 * k &lt;= N_) &#123;</div><div class="line">        // j is the left children</div><div class="line">        int j = 2 * k;</div><div class="line">        if (j &lt; N_ &amp;&amp; pq_[j] &lt; pq_[j + 1]) &#123;</div><div class="line">            // now, j is the bigger children</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (pq_[k] &gt; pq_[j]) &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // if parent node is smaller than the bigger children, exchange</div><div class="line">        exch(pq_[k], pq_[j]);</div><div class="line">        </div><div class="line">        // sink down a level</div><div class="line">        k = j;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于一个有n个记录的堆来说，一次下沉最多只需要$$\begin{align}\lg(n)\end{align}$$次操作，因此，取得最小值的操作的时间复杂度为$$\begin{align}O(\log(n))\end{align}$$</p>
<h2 id="更快的构建堆的方法"><a href="#更快的构建堆的方法" class="headerlink" title="更快的构建堆的方法"></a>更快的构建堆的方法</h2><p>一条一条地插入记录来构造堆的方法需要$$\begin{align}O(n\log(n))\end{align}$$的时间复杂度，如果记录序列全部已知，我们可以采用一种自底向上的构造方法，基本思路是从底端不是叶子结点的记录开始，做下沉操作，这样只需处理n/2个结点，这个时间复杂度基本上是线性的。下面是最大堆的下沉操作和构造方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">  void sink(std::vector&lt;T&gt;&amp; a, int k, int N) &#123;</div><div class="line">      // NOTE: the value of node k is a[k - 1]</div><div class="line">      </div><div class="line">      // make sure k is not the bottom level</div><div class="line">      while (2 * k &lt; N) &#123;</div><div class="line">          // j is the left children</div><div class="line">          int j = 2 * k;</div><div class="line">          if (j &lt; N &amp;&amp; a[j - 1] &lt; a[j]) &#123;</div><div class="line">              // now, j is the bigger children</div><div class="line">              j++;</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">          if (a[k - 1] &gt; a[j - 1]) &#123;</div><div class="line">              break;</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">          // if parent node is smaller than the bigger children, exchange</div><div class="line">          exch(a[k - 1], a[j - 1]);</div><div class="line">          </div><div class="line">          // sink down a level</div><div class="line">          k = j;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  // Heap construction</div><div class="line">  for (int k = N / 2; k &gt;= 1; --k) &#123;</div><div class="line">      // loop for every non leaf node</div><div class="line">      sink(pq, k, N);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>堆排序实现(这里用到了上面的最大堆的下沉方法)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void heap_sort(std::vector&lt;T&gt;&amp; pq) &#123;</div><div class="line">    int N = pq.size();</div><div class="line">    </div><div class="line">    // Heap construction</div><div class="line">    for (int k = N / 2; k &gt;= 1; --k) &#123;</div><div class="line">        // loop for every non leaf node</div><div class="line">        sink(pq, k, N);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Sort down</div><div class="line">    while(N &gt; 1) &#123;</div><div class="line">        exch(pq[0], pq[N - 1]);</div><div class="line">        sink(pq, 1, --N);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本特点</p>
<ul>
<li>最坏的情况下也能达到$$\begin{align}O(n\log(n))\end{align}$$，这是排序算法的理论最优。</li>
<li>缺点在于内部循环较长，无法使用缓存，并且是不稳定的，在实际中并不是最快的</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序体现了分治的策略。主要思想是把大问题分解成小问题，不断递归去求解。</p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">// merge tow subarray</div><div class="line">template&lt;typename T&gt;</div><div class="line">void merge(std::vector&lt;T&gt;&amp; a, std::vector&lt;T&gt;&amp; aux, int lo, int mid, int hi) &#123;</div><div class="line">    for (int i = lo; i &lt;= hi; ++i) &#123;</div><div class="line">        aux[i] = a[i];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int m = lo;</div><div class="line">    int n = mid + 1;</div><div class="line">    for (int i = lo; i &lt;= hi; ++i) &#123;</div><div class="line">        if (m &gt; mid) &#123;</div><div class="line">            a[i] = aux[n++];</div><div class="line">        &#125; else if (n &gt; hi) &#123;</div><div class="line">            a[i] = aux[m++];</div><div class="line">        &#125; else if (aux[n] &lt; aux[m]) &#123;</div><div class="line">            a[i] = aux[n++];</div><div class="line">        &#125; else &#123;</div><div class="line">            a[i] = aux[m++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// resuive sort</div><div class="line">const int CUTOFF = 7;</div><div class="line">template&lt;typename T&gt;</div><div class="line">void merge_sort(std::vector&lt;T&gt;&amp; a, std::vector&lt;T&gt;&amp; aux, int lo, int hi) &#123;</div><div class="line">    if (hi &lt;= lo) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // use insertion sort for small subarrays</div><div class="line">    if (hi &lt;= lo + CUTOFF - 1) &#123;</div><div class="line">        insertion_sort(a, lo, hi);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int mid = lo + (hi - lo) / 2;</div><div class="line">    merge_sort(a, aux, lo, mid);</div><div class="line">    merge_sort(a, aux, mid + 1, hi);</div><div class="line">    </div><div class="line">    // do not merge if already sorted</div><div class="line">    if (a[mid] &lt; a[mid + 1]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    merge(a, aux, lo, mid, hi);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述实现中借助了一个额外的aux数组来存储记录，并且在子问题规模很小时采用了插入排序。</p>
<p>基本特点</p>
<ul>
<li>归并排序的平均时间复杂度为$$\begin{align}O(n\log(n))\end{align}$$</li>
<li>归并排序不是原地排序，需要额外的存储空间</li>
</ul>
<h2 id="归并排序的非递归实现"><a href="#归并排序的非递归实现" class="headerlink" title="归并排序的非递归实现"></a>归并排序的非递归实现</h2><p>基本思想</p>
<ol>
<li>遍历数组，首先归并排序大小为1的子数组</li>
<li>继续遍历，不断归并大小为2，4，16的子数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void bottom_up_merge_sort(std::vector&lt;T&gt;&amp; a, std::vector&lt;T&gt;&amp; aux, int lo, int hi) &#123;</div><div class="line">    int N = hi - lo + 1;</div><div class="line">    for (int sz = 1; sz &lt; N; sz += sz) &#123;</div><div class="line">        for (int k = lo; k &lt; lo + N - sz; k += (sz + sz)) &#123;</div><div class="line">            merge(a, aux, k, k + sz - 1, std::min(k + sz + sz - 1, N - 1));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本特点</p>
<ul>
<li>如果有足够的空间的话，非递归的归并排序的稳定性是工业级别的</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序和归并排序类似，都是递归的算法，通过把问题分解为子问题来解决。不同的是，归并排序每次都把问题分成相同大小的两个子问题，然后通过归并操作进行合并；而快速排序则通过拆分的方式来分解问题，即每次找一个中间元素，把记录分成小于该中间元素（在中间元素左边）和大于该中间元素（在中间元素右边）的这两部分，此时中间元素已经排好序，只需对左右两边递归继续采用相同方式拆分即可。</p>
<p>和归并排序的归并操作是线性的时间复杂度类似，快速排序的拆分操作也是线性的。归并排序和快速排序的递归分解都把问题变成了一个二叉树的结构，而归并排序的二叉树是完全二叉树，因此树高是$$\begin{align}lg(n)\end{align}$$，而快速排序的树高则与中间元素的选取有很大的关系，为了达到了归并排序相似的树高，要求输入记录必须是无序的，研究表明，无序的二叉树插入的树高平均只比完全二叉树高36%，因此该种情况下的快速排序和归并排序的时间复杂度是相同的。当然由于快速排序加入了随机的因素，我们只能说平均情况下快速排序和归并排序的时间复杂度是相同的，也不排除很小的概率的情况下快速排序的时间复杂度为$$\begin{align}n^2\end{align}$$</p>
<p>基本思想</p>
<ul>
<li>随机打乱原始记录</li>
<li>针对索引为j的记录进行拆分，使得：<ul>
<li>记录a[j]位于最终已排序的位置</li>
<li>j左边的记录没有比a[j]大的</li>
<li>j右边的记录没有比a[j]小的</li>
</ul>
</li>
<li>对拆分后的各个部分递归进行上述处理</li>
</ul>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">int partition(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123;</div><div class="line">    int i = lo;</div><div class="line">    int j = hi + 1;</div><div class="line">    </div><div class="line">    while(true) &#123;</div><div class="line">        // process i pointer</div><div class="line">        // find item on left to swap</div><div class="line">        while(a[++i] &lt; a[lo]) &#123;</div><div class="line">            if (i == hi) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // process j pointer</div><div class="line">        // find item on right to swap</div><div class="line">        while(a[--j] &gt; a[lo]) &#123;</div><div class="line">            if (j == lo) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // find if pointers cross</div><div class="line">        if (i &gt;= j) &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // swap</div><div class="line">        exch(a[i], a[j]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // swap with partition item</div><div class="line">    exch(a[lo], a[j]);</div><div class="line">    </div><div class="line">    // return index of item now known to be in place</div><div class="line">    return j;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line">void quick_sort_sub(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123;</div><div class="line">    if (hi &lt;= lo + CUTOFF) &#123;</div><div class="line">        // improvement 1:  use insertion fort for small subarray</div><div class="line">        insertion_sort(a, lo, hi);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // improvement 2: estimate partition item with median of three samples</div><div class="line">    int m = median_of_three(a, lo, lo + (hi - lo)/ 2, hi);</div><div class="line">    exch(a[lo], a[m]);</div><div class="line">    </div><div class="line">    int j = partition(a, lo, hi);</div><div class="line">    quick_sort_sub(a, lo, j - 1);</div><div class="line">    quick_sort_sub(a, j + 1, hi);</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line">void quick_sort(std::vector&lt;T&gt;&amp; a) &#123;</div><div class="line">    // shuffle is needed for performance guarantee</div><div class="line">    shuffle(a);</div><div class="line">    </div><div class="line">    quick_sort_sub&lt;T&gt;(a, 0, static_cast&lt;int&gt;(a.size()) - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码使用了两个提升：和归并排序中一样，我们在记录序列很小时采用了插入排序；另外我们本来是采用随机打乱后的记录顺序来选取中间值，为了让得到的二叉树更加平衡，我们需要选择接近数列中位数的记录作为中间值，这里我们采用了抽样的方式来计算中值。</p>
<p>基本特点</p>
<p>虽然快速排序理论上只能在概率上趋近于$$\begin{align}nlg(n)\end{align}$$的时间复杂度，但是由于它的内层循环较小，并且容易利用计算机缓存等原因，一个设计得很好的快速排序的效率是归并排序和堆排序的2-3倍！</p>
<p>在实际应用中，如果记录有许多重复的话，会发现快速排序接近于$$\begin{align}n^2\end{align}$$的时间复杂度，这时候我们需要使用快速排序的改进版：3路快速排序</p>
<h2 id="3路快速排序"><a href="#3路快速排序" class="headerlink" title="3路快速排序"></a>3路快速排序</h2><p>基本思想是：</p>
<ul>
<li>把记录序列查分成3部分（而不是之前的两部分）</li>
<li>在lt和gt中间的记录都等于中间元素</li>
<li>lt左边的记录都不大于中间元素</li>
<li>lt右边的记录都不小于中间元素</li>
</ul>
<p>实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// * Let v be partitioning item a[lo].</div><div class="line">// * Scan i from left to right.</div><div class="line">//  - (a[i] &lt; v): exchange a[lt] with a[i]; increment both lt and i</div><div class="line">//  - (a[i] &gt; v): exchange a[gt] with a[i]; decrement gt;</div><div class="line">//  - (a[i] == v): increment i</div><div class="line">template&lt;typename T&gt;</div><div class="line">void quick_sort_3way_sub(std::vector&lt;T&gt;&amp; a, int lo, int hi) &#123;</div><div class="line">    if (hi &lt;= lo + CUTOFF) &#123;</div><div class="line">        // improvement 1:  use insertion fort for small subarray</div><div class="line">        insertion_sort(a, lo, hi);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int lt = lo;</div><div class="line">    int i = lo;</div><div class="line">    int gt = hi;</div><div class="line">    </div><div class="line">    // improvement 2: estimate partition item with median of three samples</div><div class="line">    int m = median_of_three(a, lo, lo + (hi - lo)/ 2, hi);</div><div class="line">    exch(a[lo], a[m]);</div><div class="line">    </div><div class="line">    // partition item</div><div class="line">    T v = a[lo];</div><div class="line">    </div><div class="line">    while(i &lt;= gt) &#123;</div><div class="line">        if (a[i] &lt; v) &#123;</div><div class="line">            exch(a[lt++], a[i++]);</div><div class="line">        &#125; else if (a[i] &gt; v) &#123;</div><div class="line">            exch(a[i], a[gt--]);</div><div class="line">        &#125; else &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    quick_sort_3way_sub(a, lo, lt - 1);</div><div class="line">    quick_sort_3way_sub(a, gt + 1, hi);</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line">void quick_sort_3way(std::vector&lt;T&gt;&amp; a) &#123;</div><div class="line">    // shuffle is needed for performance guarantee</div><div class="line">    shuffle(a);</div><div class="line">    </div><div class="line">    quick_sort_3way_sub&lt;T&gt;(a, 0, static_cast&lt;int&gt;(a.size()) - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，经典的排序方法已经介绍完毕。除了选择排序和插入排序需要二次的时间复杂度外，堆排序、归并排序以及快速排序都能达到$$\begin{align}nlg(n)\end{align}$$的时间复杂度，而这也是证明了的排序算法时间复杂度的下界，即这已经是最优算法了。但是从之前的讨论可以看到，在实际情况中，受到各种因素的限制，时间复杂度相同的算法的实际效率并不同，并且有可能相差数倍，当然，这是大O方式来衡量时间复杂度的一个弊端：即它只能忽略影响算法效率的其它因素，单单从输入规模上来看算法运行时间随输入规模的变化。从这个角度来看，虽然堆排序、归并排序以及快速排序都是最优算法，但是还可能有更快的排序算法等待着我们去发掘。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cartosquare.github.io/2016/04/22/2016-04-22-sorting-algorithms/" data-id="cis0h2tb600021djg6khi87ab" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/07/2016-05-07-minutely-osm-database/">实时更新OSM数据库</a>
          </li>
        
          <li>
            <a href="/2016/04/22/2016-04-22-sorting-algorithms/">排序算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 徐翔<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>